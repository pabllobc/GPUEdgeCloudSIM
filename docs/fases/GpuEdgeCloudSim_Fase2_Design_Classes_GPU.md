# üé® GpuEdgeCloudSim - Fase 2: Design Detalhado das Classes GPU

**Autor:** Pabllo Borges Cardoso  
**Data:** 23 de Outubro de 2025  
**Vers√£o:** 1.0  
**Projeto:** GpuEdgeCloudSim v1.0 - Extens√£o GPU do EdgeCloudSim

---

## üìã Sum√°rio Executivo

Este documento apresenta o **design completo e detalhado** das classes GPU para o **GpuEdgeCloudSim**, incluindo especifica√ß√µes de API, diagramas UML, contratos de interface, diagramas de sequ√™ncia, exemplos de uso e estrat√©gias de teste.

### Contexto da Fase 2

A **Fase 1 (An√°lise Arquitetural)** identificou 5 pontos cr√≠ticos de extens√£o no EdgeCloudSim. Esta Fase 2 detalha o design t√©cnico necess√°rio para implementa√ß√£o na **Fase 3**.

### Escopo do Design

Este documento especifica **10 classes GPU principais**:

1. **Gpu** - Representa√ß√£o f√≠sica de uma GPU
2. **GpuProvisioner** - Interface para aloca√ß√£o de GPU
3. **GpuProvisionerSimple** - Implementa√ß√£o simples de provisionamento
4. **GpuTask** - Tarefa com requisitos GPU
5. **GpuEdgeHost** - Host edge com GPUs f√≠sicas
6. **GpuEdgeVM** - VM com GPU alocada
7. **GpuCloudletScheduler** - Interface para escalonamento GPU
8. **GpuCloudletSchedulerTimeShared** - Implementa√ß√£o time-shared
9. **GpuEdgeServerManager** - Gerenciador de infraestrutura GPU
10. **GpuEdgeVmAllocationPolicy_Custom** - Pol√≠tica de aloca√ß√£o GPU-aware

---

## üìë √çndice

1. [Especifica√ß√µes Completas de APIs](#1-especifica√ß√µes-completas-de-apis)
2. [Diagramas UML Detalhados](#2-diagramas-uml-detalhados)
3. [Contratos de Interfaces](#3-contratos-de-interfaces)
4. [Diagramas de Sequ√™ncia](#4-diagramas-de-sequ√™ncia)
5. [Exemplos de Uso](#5-exemplos-de-uso)
6. [Estrat√©gias de Teste](#6-estrat√©gias-de-teste)
7. [Decis√µes de Design](#7-decis√µes-de-design)
8. [Anexos](#8-anexos)

---

## 1. Especifica√ß√µes Completas de APIs

### 1.1 Classe: Gpu

**Pacote:** `edu.boun.edgecloudsim.edge_server`

**Prop√≥sito:** Representa uma GPU f√≠sica em um EdgeHost, modelando suas caracter√≠sticas de hardware e estado de utiliza√ß√£o.

**Relacionamentos:**
- Agregada por: `GpuEdgeHost`
- Alocada para: `GpuEdgeVM`
- Gerenciada por: `GpuProvisioner`

#### Atributos

```java
/**
 * Identificador √∫nico da GPU dentro do host.
 * @visibility private
 * @type int
 */
private int id;

/**
 * Tipo/modelo da GPU (ex: "NVIDIA_T4", "NVIDIA_A100").
 * @visibility private
 * @type String
 */
private String gpuType;

/**
 * N√∫mero de CUDA cores dispon√≠veis.
 * @visibility private
 * @type int
 */
private int cudaCores;

/**
 * Capacidade computacional em GFLOPS (Giga Floating Point Operations Per Second).
 * @visibility private
 * @type double
 */
private double gflops;

/**
 * Mem√≥ria total da GPU em MB.
 * @visibility private
 * @type long
 */
private long gpuMemory;

/**
 * Largura de banda da mem√≥ria GPU em GB/s.
 * @visibility private
 * @type double
 */
private double memoryBandwidth;

/**
 * Utiliza√ß√£o atual da GPU em percentual (0-100%).
 * @visibility private
 * @type double
 */
private double utilization;

/**
 * Mem√≥ria GPU atualmente ocupada em MB.
 * @visibility private
 * @type long
 */
private long usedMemory;

/**
 * VM atualmente alocada nesta GPU (null se dispon√≠vel).
 * @visibility private
 * @type GpuEdgeVM
 */
private GpuEdgeVM allocatedVm;

/**
 * Host que cont√©m esta GPU.
 * @visibility private
 * @type GpuEdgeHost
 */
private GpuEdgeHost host;
```

#### Construtores

```java
/**
 * Construtor completo para criar uma GPU com todas as especifica√ß√µes.
 * 
 * @param id Identificador √∫nico da GPU
 * @param gpuType Tipo/modelo da GPU
 * @param cudaCores N√∫mero de CUDA cores
 * @param gflops Capacidade em GFLOPS
 * @param gpuMemory Mem√≥ria total em MB
 * @param memoryBandwidth Largura de banda em GB/s
 */
public Gpu(int id, String gpuType, int cudaCores, double gflops, 
           long gpuMemory, double memoryBandwidth)

/**
 * Construtor simplificado para criar uma GPU com especifica√ß√µes b√°sicas.
 * 
 * @param id Identificador √∫nico da GPU
 * @param cudaCores N√∫mero de CUDA cores
 * @param gflops Capacidade em GFLOPS
 * @param gpuMemory Mem√≥ria total em MB
 */
public Gpu(int id, int cudaCores, double gflops, long gpuMemory)
```

#### M√©todos

##### Getters B√°sicos

```java
/**
 * Retorna o identificador √∫nico da GPU.
 * @return ID da GPU
 */
public int getId()

/**
 * Retorna o tipo/modelo da GPU.
 * @return Tipo da GPU (ex: "NVIDIA_T4")
 */
public String getGpuType()

/**
 * Retorna o n√∫mero de CUDA cores.
 * @return N√∫mero de CUDA cores
 */
public int getCudaCores()

/**
 * Retorna a capacidade computacional em GFLOPS.
 * @return Capacidade em GFLOPS
 */
public double getGflops()

/**
 * Retorna a mem√≥ria total da GPU em MB.
 * @return Mem√≥ria total em MB
 */
public long getGpuMemory()

/**
 * Retorna a largura de banda da mem√≥ria em GB/s.
 * @return Largura de banda em GB/s
 */
public double getMemoryBandwidth()

/**
 * Retorna o host que cont√©m esta GPU.
 * @return Host da GPU
 */
public GpuEdgeHost getHost()
```

##### Getters de Estado

```java
/**
 * Retorna a utiliza√ß√£o atual da GPU em percentual.
 * @return Utiliza√ß√£o (0-100%)
 */
public double getUtilization()

/**
 * Retorna a mem√≥ria GPU atualmente ocupada em MB.
 * @return Mem√≥ria ocupada em MB
 */
public long getUsedMemory()

/**
 * Retorna a mem√≥ria GPU dispon√≠vel em MB.
 * @return Mem√≥ria dispon√≠vel em MB
 */
public long getAvailableMemory()

/**
 * Retorna a VM atualmente alocada nesta GPU.
 * @return VM alocada ou null se dispon√≠vel
 */
public GpuEdgeVM getAllocatedVm()

/**
 * Verifica se a GPU est√° dispon√≠vel (n√£o alocada).
 * @return true se dispon√≠vel, false caso contr√°rio
 */
public boolean isAvailable()
```

##### Setters

```java
/**
 * Define o host que cont√©m esta GPU.
 * @param host Host da GPU
 */
public void setHost(GpuEdgeHost host)

/**
 * Define a utiliza√ß√£o atual da GPU.
 * @param utilization Utiliza√ß√£o em percentual (0-100%)
 */
public void setUtilization(double utilization)

/**
 * Define a mem√≥ria GPU atualmente ocupada.
 * @param usedMemory Mem√≥ria ocupada em MB
 */
public void setUsedMemory(long usedMemory)

/**
 * Define a VM alocada nesta GPU.
 * @param vm VM a ser alocada (null para desalocar)
 */
public void setAllocatedVm(GpuEdgeVM vm)
```

##### M√©todos de Gerenciamento

```java
/**
 * Aloca mem√≥ria GPU para uma tarefa.
 * 
 * @param memorySize Quantidade de mem√≥ria a alocar em MB
 * @return true se a aloca√ß√£o foi bem-sucedida, false caso contr√°rio
 */
public boolean allocateMemory(long memorySize)

/**
 * Libera mem√≥ria GPU previamente alocada.
 * 
 * @param memorySize Quantidade de mem√≥ria a liberar em MB
 * @return true se a libera√ß√£o foi bem-sucedida, false caso contr√°rio
 */
public boolean deallocateMemory(long memorySize)

/**
 * Calcula o tempo de execu√ß√£o de uma tarefa nesta GPU.
 * 
 * @param gpuLength Tamanho da tarefa em GFLOPs
 * @return Tempo de execu√ß√£o em segundos
 */
public double calculateExecutionTime(long gpuLength)

/**
 * Calcula o tempo de transfer√™ncia de dados para a GPU.
 * 
 * @param dataSize Tamanho dos dados em MB
 * @return Tempo de transfer√™ncia em segundos
 */
public double calculateDataTransferTime(long dataSize)

/**
 * Reseta a GPU para o estado inicial (dispon√≠vel).
 */
public void reset()
```

##### M√©todos de String

```java
/**
 * Retorna representa√ß√£o em string da GPU.
 * @return String com informa√ß√µes b√°sicas da GPU
 */
@Override
public String toString()
```

---

### 1.2 Interface: GpuProvisioner

**Pacote:** `edu.boun.edgecloudsim.edge_server`

**Prop√≥sito:** Define o contrato para provisionamento de GPUs para VMs.

**Implementa√ß√µes:** `GpuProvisionerSimple`

#### M√©todos

```java
/**
 * Aloca uma GPU espec√≠fica para uma VM.
 * 
 * @param vm VM que receber√° a GPU
 * @param gpu GPU a ser alocada
 * @return true se a aloca√ß√£o foi bem-sucedida, false caso contr√°rio
 */
boolean allocateGpuForVm(GpuEdgeVM vm, Gpu gpu);

/**
 * Desaloca a GPU de uma VM, tornando-a dispon√≠vel.
 * 
 * @param vm VM da qual a GPU ser√° desalocada
 */
void deallocateGpuForVm(GpuEdgeVM vm);

/**
 * Verifica se h√° GPUs dispon√≠veis no pool.
 * 
 * @return true se h√° pelo menos uma GPU dispon√≠vel, false caso contr√°rio
 */
boolean hasAvailableGpu();

/**
 * Retorna uma GPU dispon√≠vel do pool.
 * Estrat√©gia de sele√ß√£o depende da implementa√ß√£o.
 * 
 * @return GPU dispon√≠vel ou null se n√£o houver
 */
Gpu getAvailableGpu();

/**
 * Retorna uma GPU dispon√≠vel com mem√≥ria suficiente.
 * 
 * @param requiredMemory Mem√≥ria m√≠nima necess√°ria em MB
 * @return GPU dispon√≠vel com mem√≥ria suficiente ou null
 */
Gpu getAvailableGpuWithMemory(long requiredMemory);

/**
 * Retorna a lista completa de GPUs gerenciadas.
 * 
 * @return Lista de todas as GPUs
 */
List<Gpu> getGpuList();

/**
 * Retorna a lista de GPUs dispon√≠veis (n√£o alocadas).
 * 
 * @return Lista de GPUs dispon√≠veis
 */
List<Gpu> getAvailableGpuList();

/**
 * Retorna a lista de GPUs alocadas.
 * 
 * @return Lista de GPUs alocadas
 */
List<Gpu> getAllocatedGpuList();
```

---

### 1.3 Classe: GpuProvisionerSimple

**Pacote:** `edu.boun.edgecloudsim.edge_server`

**Prop√≥sito:** Implementa√ß√£o simples de provisionamento de GPU com aloca√ß√£o exclusiva (1 GPU : 1 VM).

**Relacionamentos:**
- Implementa: `GpuProvisioner`
- Usado por: `GpuEdgeHost`

#### Atributos

```java
/**
 * Lista de GPUs gerenciadas por este provisioner.
 * @visibility private
 * @type List<Gpu>
 */
private List<Gpu> gpuList;

/**
 * Mapa para rastrear aloca√ß√µes VM -> GPU.
 * @visibility private
 * @type Map<Integer, Gpu>
 */
private Map<Integer, Gpu> vmGpuMap;
```

#### Construtores

```java
/**
 * Construtor que inicializa o provisioner com uma lista de GPUs.
 * 
 * @param gpuList Lista de GPUs a serem gerenciadas
 */
public GpuProvisionerSimple(List<Gpu> gpuList)
```

#### M√©todos

```java
/**
 * Aloca uma GPU espec√≠fica para uma VM (modo exclusivo).
 * Verifica disponibilidade antes de alocar.
 * 
 * @param vm VM que receber√° a GPU
 * @param gpu GPU a ser alocada
 * @return true se a aloca√ß√£o foi bem-sucedida, false caso contr√°rio
 */
@Override
public boolean allocateGpuForVm(GpuEdgeVM vm, Gpu gpu)

/**
 * Desaloca a GPU de uma VM.
 * Reseta o estado da GPU e remove do mapa de aloca√ß√µes.
 * 
 * @param vm VM da qual a GPU ser√° desalocada
 */
@Override
public void deallocateGpuForVm(GpuEdgeVM vm)

/**
 * Verifica se h√° GPUs dispon√≠veis.
 * 
 * @return true se h√° pelo menos uma GPU dispon√≠vel
 */
@Override
public boolean hasAvailableGpu()

/**
 * Retorna a primeira GPU dispon√≠vel encontrada.
 * 
 * @return GPU dispon√≠vel ou null
 */
@Override
public Gpu getAvailableGpu()

/**
 * Retorna uma GPU dispon√≠vel com mem√≥ria suficiente.
 * 
 * @param requiredMemory Mem√≥ria m√≠nima necess√°ria em MB
 * @return GPU dispon√≠vel com mem√≥ria suficiente ou null
 */
@Override
public Gpu getAvailableGpuWithMemory(long requiredMemory)

/**
 * Retorna a lista completa de GPUs.
 * 
 * @return Lista imut√°vel de GPUs
 */
@Override
public List<Gpu> getGpuList()

/**
 * Retorna a lista de GPUs dispon√≠veis.
 * 
 * @return Lista de GPUs n√£o alocadas
 */
@Override
public List<Gpu> getAvailableGpuList()

/**
 * Retorna a lista de GPUs alocadas.
 * 
 * @return Lista de GPUs alocadas
 */
@Override
public List<Gpu> getAllocatedGpuList()

/**
 * Retorna a GPU alocada para uma VM espec√≠fica.
 * 
 * @param vmId ID da VM
 * @return GPU alocada para a VM ou null
 */
public Gpu getGpuForVm(int vmId)

/**
 * Calcula a utiliza√ß√£o m√©dia de todas as GPUs.
 * 
 * @return Utiliza√ß√£o m√©dia em percentual (0-100%)
 */
public double getAverageUtilization()
```

---

### 1.4 Classe: GpuTask

**Pacote:** `edu.boun.edgecloudsim.edge_client`

**Prop√≥sito:** Estende Task para incluir requisitos e m√©tricas de processamento GPU.

**Relacionamentos:**
- Estende: `Task`
- Processada por: `GpuEdgeVM`
- Escalonada por: `GpuCloudletScheduler`

#### Atributos

```java
/**
 * Tamanho da carga de trabalho GPU em GFLOPs.
 * @visibility private
 * @type long
 */
private long gpuLength;

/**
 * Tamanho dos dados de entrada para a GPU em MB.
 * @visibility private
 * @type long
 */
private long gpuInputData;

/**
 * Tamanho dos dados de sa√≠da da GPU em MB.
 * @visibility private
 * @type long
 */
private long gpuOutputData;

/**
 * Mem√≥ria GPU necess√°ria em MB.
 * @visibility private
 * @type long
 */
private long requiredGpuMemory;

/**
 * Utiliza√ß√£o GPU esperada em percentual (0-100%).
 * @visibility private
 * @type double
 */
private double expectedGpuUtilization;

/**
 * ID da GPU onde esta tarefa foi executada.
 * @visibility private
 * @type int
 */
private int executedGpuId;

/**
 * Tempo de transfer√™ncia CPU ‚Üí GPU em segundos.
 * @visibility private
 * @type double
 */
private double gpuDataTransferTime;

/**
 * Tempo de execu√ß√£o na GPU em segundos.
 * @visibility private
 * @type double
 */
private double gpuExecutionTime;

/**
 * Tempo de transfer√™ncia GPU ‚Üí CPU em segundos.
 * @visibility private
 * @type double
 */
private double gpuDataBackTime;

/**
 * Utiliza√ß√£o GPU real durante a execu√ß√£o (0-100%).
 * @visibility private
 * @type double
 */
private double actualGpuUtilization;

/**
 * Timestamp do in√≠cio da transfer√™ncia CPU ‚Üí GPU.
 * @visibility private
 * @type double
 */
private double gpuStartTime;

/**
 * Timestamp do fim da execu√ß√£o GPU completa.
 * @visibility private
 * @type double
 */
private double gpuFinishTime;
```

#### Construtores

```java
/**
 * Construtor completo para GpuTask com requisitos CPU e GPU.
 * 
 * @param mobileDeviceId ID do dispositivo que gerou a tarefa
 * @param cloudletId ID √∫nico da tarefa
 * @param cloudletLength Tamanho do processamento CPU em MI
 * @param pesNumber N√∫mero de PEs (CPU cores) necess√°rios
 * @param cloudletFileSize Tamanho do arquivo de entrada em bytes
 * @param cloudletOutputSize Tamanho do arquivo de sa√≠da em bytes
 * @param utilizationModelCpu Modelo de utiliza√ß√£o de CPU
 * @param utilizationModelRam Modelo de utiliza√ß√£o de RAM
 * @param utilizationModelBw Modelo de utiliza√ß√£o de largura de banda
 * @param gpuLength Tamanho da carga GPU em GFLOPs
 * @param gpuInputData Dados de entrada para GPU em MB
 * @param gpuOutputData Dados de sa√≠da da GPU em MB
 * @param requiredGpuMemory Mem√≥ria GPU necess√°ria em MB
 */
public GpuTask(int mobileDeviceId, int cloudletId, long cloudletLength, 
               int pesNumber, long cloudletFileSize, long cloudletOutputSize,
               UtilizationModel utilizationModelCpu,
               UtilizationModel utilizationModelRam,
               UtilizationModel utilizationModelBw,
               long gpuLength, long gpuInputData, long gpuOutputData,
               long requiredGpuMemory)

/**
 * Construtor simplificado para GpuTask (herda Task).
 * 
 * @param cloudletId ID √∫nico da tarefa
 * @param taskId ID do tipo de tarefa
 * @param cloudletLength Tamanho do processamento CPU em MI
 * @param pesNumber N√∫mero de PEs necess√°rios
 * @param cloudletFileSize Tamanho do arquivo de entrada
 * @param cloudletOutputSize Tamanho do arquivo de sa√≠da
 * @param gpuLength Tamanho da carga GPU em GFLOPs
 * @param gpuInputData Dados de entrada para GPU em MB
 * @param gpuOutputData Dados de sa√≠da da GPU em MB
 * @param requiredGpuMemory Mem√≥ria GPU necess√°ria em MB
 */
public GpuTask(int cloudletId, int taskId, long cloudletLength, 
               long pesNumber, long cloudletFileSize, long cloudletOutputSize,
               long gpuLength, long gpuInputData, long gpuOutputData,
               long requiredGpuMemory)
```

#### M√©todos

##### Getters de Requisitos GPU

```java
/**
 * Retorna o tamanho da carga de trabalho GPU.
 * @return Tamanho em GFLOPs
 */
public long getGpuLength()

/**
 * Retorna o tamanho dos dados de entrada para GPU.
 * @return Tamanho em MB
 */
public long getGpuInputData()

/**
 * Retorna o tamanho dos dados de sa√≠da da GPU.
 * @return Tamanho em MB
 */
public long getGpuOutputData()

/**
 * Retorna a mem√≥ria GPU necess√°ria.
 * @return Mem√≥ria em MB
 */
public long getRequiredGpuMemory()

/**
 * Retorna a utiliza√ß√£o GPU esperada.
 * @return Utiliza√ß√£o esperada em percentual (0-100%)
 */
public double getExpectedGpuUtilization()
```

##### Getters de M√©tricas GPU

```java
/**
 * Retorna o ID da GPU onde a tarefa foi executada.
 * @return ID da GPU ou -1 se n√£o executada
 */
public int getExecutedGpuId()

/**
 * Retorna o tempo de transfer√™ncia CPU ‚Üí GPU.
 * @return Tempo em segundos
 */
public double getGpuDataTransferTime()

/**
 * Retorna o tempo de execu√ß√£o na GPU.
 * @return Tempo em segundos
 */
public double getGpuExecutionTime()

/**
 * Retorna o tempo de transfer√™ncia GPU ‚Üí CPU.
 * @return Tempo em segundos
 */
public double getGpuDataBackTime()

/**
 * Retorna a utiliza√ß√£o GPU real durante execu√ß√£o.
 * @return Utiliza√ß√£o em percentual (0-100%)
 */
public double getActualGpuUtilization()

/**
 * Retorna o timestamp de in√≠cio da execu√ß√£o GPU.
 * @return Timestamp em segundos de simula√ß√£o
 */
public double getGpuStartTime()

/**
 * Retorna o timestamp de fim da execu√ß√£o GPU.
 * @return Timestamp em segundos de simula√ß√£o
 */
public double getGpuFinishTime()
```

##### Setters de M√©tricas GPU

```java
/**
 * Define o ID da GPU onde a tarefa foi executada.
 * @param gpuId ID da GPU
 */
public void setExecutedGpuId(int gpuId)

/**
 * Define o tempo de transfer√™ncia CPU ‚Üí GPU.
 * @param time Tempo em segundos
 */
public void setGpuDataTransferTime(double time)

/**
 * Define o tempo de execu√ß√£o na GPU.
 * @param time Tempo em segundos
 */
public void setGpuExecutionTime(double time)

/**
 * Define o tempo de transfer√™ncia GPU ‚Üí CPU.
 * @param time Tempo em segundos
 */
public void setGpuDataBackTime(double time)

/**
 * Define a utiliza√ß√£o GPU real durante execu√ß√£o.
 * @param utilization Utiliza√ß√£o em percentual (0-100%)
 */
public void setActualGpuUtilization(double utilization)

/**
 * Define o timestamp de in√≠cio da execu√ß√£o GPU.
 * @param time Timestamp em segundos de simula√ß√£o
 */
public void setGpuStartTime(double time)

/**
 * Define o timestamp de fim da execu√ß√£o GPU.
 * @param time Timestamp em segundos de simula√ß√£o
 */
public void setGpuFinishTime(double time)

/**
 * Define a utiliza√ß√£o GPU esperada.
 * @param utilization Utiliza√ß√£o esperada em percentual (0-100%)
 */
public void setExpectedGpuUtilization(double utilization)
```

##### M√©todos de C√°lculo

```java
/**
 * Calcula o tempo total de processamento GPU.
 * Inclui transfer√™ncias de dados e execu√ß√£o.
 * 
 * @return Tempo total em segundos
 */
public double getTotalGpuTime()

/**
 * Verifica se esta tarefa requer processamento GPU.
 * 
 * @return true se gpuLength > 0, false caso contr√°rio
 */
public boolean requiresGpu()

/**
 * Calcula a propor√ß√£o de processamento GPU em rela√ß√£o ao total.
 * 
 * @return Raz√£o GPU/(CPU+GPU) entre 0 e 1
 */
public double getGpuIntensity()

/**
 * Verifica se a tarefa tem mem√≥ria GPU suficiente alocada.
 * 
 * @param availableMemory Mem√≥ria dispon√≠vel em MB
 * @return true se a mem√≥ria √© suficiente, false caso contr√°rio
 */
public boolean hasEnoughGpuMemory(long availableMemory)
```

---

### 1.5 Classe: GpuEdgeHost

**Pacote:** `edu.boun.edgecloudsim.edge_server`

**Prop√≥sito:** Estende EdgeHost para incluir gerenciamento de GPUs f√≠sicas.

**Relacionamentos:**
- Estende: `EdgeHost`
- Cont√©m: `List<Gpu>`
- Usa: `GpuProvisioner`
- Gerencia: `GpuEdgeVM`

#### Atributos

```java
/**
 * Lista de GPUs f√≠sicas dispon√≠veis neste host.
 * @visibility private
 * @type List<Gpu>
 */
private List<Gpu> gpuList;

/**
 * Provisionador respons√°vel por alocar GPUs para VMs.
 * @visibility private
 * @type GpuProvisioner
 */
private GpuProvisioner gpuProvisioner;
```

#### Construtores

```java
/**
 * Construtor completo para GpuEdgeHost com recursos CPU e GPU.
 * 
 * @param id Identificador √∫nico do host
 * @param ramProvisioner Provisionador de mem√≥ria RAM
 * @param bwProvisioner Provisionador de largura de banda
 * @param storage Capacidade de armazenamento em MB
 * @param peList Lista de elementos de processamento (CPU cores)
 * @param vmScheduler Escalonador de VMs
 * @param gpuList Lista de GPUs dispon√≠veis
 * @param gpuProvisioner Provisionador de GPUs
 */
public GpuEdgeHost(int id, RamProvisioner ramProvisioner,
                   BwProvisioner bwProvisioner, long storage,
                   List<? extends Pe> peList, VmScheduler vmScheduler,
                   List<Gpu> gpuList, GpuProvisioner gpuProvisioner)
```

#### M√©todos

##### Getters

```java
/**
 * Retorna a lista de GPUs deste host.
 * @return Lista de GPUs
 */
public List<Gpu> getGpuList()

/**
 * Retorna o provisionador de GPU.
 * @return Provisionador de GPU
 */
public GpuProvisioner getGpuProvisioner()

/**
 * Retorna o n√∫mero total de GPUs neste host.
 * @return N√∫mero de GPUs
 */
public int getNumberOfGpus()

/**
 * Retorna uma GPU espec√≠fica pelo ID.
 * 
 * @param gpuId ID da GPU
 * @return GPU correspondente ou null se n√£o encontrada
 */
public Gpu getGpu(int gpuId)
```

##### M√©todos de Aloca√ß√£o GPU

```java
/**
 * Aloca uma GPU espec√≠fica para uma VM.
 * Delega ao GpuProvisioner para realizar a aloca√ß√£o.
 * 
 * @param vm VM que receber√° a GPU
 * @param gpu GPU a ser alocada
 * @return true se a aloca√ß√£o foi bem-sucedida, false caso contr√°rio
 */
public boolean allocateGpuForVm(GpuEdgeVM vm, Gpu gpu)

/**
 * Desaloca a GPU de uma VM.
 * Libera a GPU para outras VMs.
 * 
 * @param vm VM da qual a GPU ser√° desalocada
 */
public void deallocateGpuForVm(GpuEdgeVM vm)

/**
 * Verifica se h√° GPUs dispon√≠veis neste host.
 * 
 * @return true se h√° pelo menos uma GPU dispon√≠vel
 */
public boolean hasAvailableGpu()

/**
 * Retorna uma GPU dispon√≠vel do pool.
 * 
 * @return GPU dispon√≠vel ou null se nenhuma dispon√≠vel
 */
public Gpu getAvailableGpu()

/**
 * Retorna uma GPU dispon√≠vel com mem√≥ria suficiente.
 * 
 * @param requiredMemory Mem√≥ria m√≠nima necess√°ria em MB
 * @return GPU dispon√≠vel com mem√≥ria suficiente ou null
 */
public Gpu getAvailableGpuWithMemory(long requiredMemory)
```

##### M√©todos de M√©tricas

```java
/**
 * Calcula a utiliza√ß√£o m√©dia de CPU e GPU.
 * Combina utiliza√ß√£o de CPU (herdada) e GPU.
 * 
 * @return Utiliza√ß√£o m√©dia em percentual (0-100%)
 */
public double getAvgUtilization()

/**
 * Calcula a utiliza√ß√£o m√©dia das GPUs.
 * 
 * @return Utiliza√ß√£o m√©dia das GPUs em percentual (0-100%)
 */
public double getAvgGpuUtilization()

/**
 * Retorna a mem√≥ria GPU total dispon√≠vel neste host.
 * 
 * @return Mem√≥ria GPU total em MB
 */
public long getTotalGpuMemory()

/**
 * Retorna a mem√≥ria GPU dispon√≠vel (n√£o alocada) neste host.
 * 
 * @return Mem√≥ria GPU dispon√≠vel em MB
 */
public long getAvailableGpuMemory()

/**
 * Retorna a capacidade computacional total de GPU em GFLOPS.
 * 
 * @return Capacidade total em GFLOPS
 */
public double getTotalGpuGflops()
```

##### M√©todos de Cria√ß√£o de VM (Override)

```java
/**
 * Cria uma VM neste host (estende comportamento do Host).
 * Se a VM requer GPU, tenta alocar uma antes de criar a VM.
 * 
 * @param vm VM a ser criada
 * @return true se a VM foi criada com sucesso, false caso contr√°rio
 */
@Override
public boolean vmCreate(Vm vm)

/**
 * Destr√≥i uma VM neste host (estende comportamento do Host).
 * Libera a GPU alocada se a VM tiver uma.
 * 
 * @param vm VM a ser destru√≠da
 */
@Override
public void vmDestroy(Vm vm)
```

---

### 1.6 Classe: GpuEdgeVM

**Pacote:** `edu.boun.edgecloudsim.edge_server`

**Prop√≥sito:** Estende EdgeVM para incluir GPU alocada e escalonamento GPU.

**Relacionamentos:**
- Estende: `EdgeVM`
- Possui: `Gpu` (alocada)
- Usa: `GpuCloudletScheduler`
- Executa: `GpuTask`

#### Atributos

```java
/**
 * GPU alocada para esta VM (null se n√£o tiver GPU).
 * @visibility private
 * @type Gpu
 */
private Gpu allocatedGpu;

/**
 * Escalonador de tarefas GPU para esta VM.
 * @visibility private
 * @type GpuCloudletScheduler
 */
private GpuCloudletScheduler gpuCloudletScheduler;

/**
 * Indica se esta VM requer GPU.
 * @visibility private
 * @type boolean
 */
private boolean requiresGpu;

/**
 * Modo de aloca√ß√£o GPU (EXCLUSIVE ou SHARED).
 * @visibility private
 * @type GpuAllocationMode
 */
private GpuAllocationMode gpuAllocationMode;
```

#### Enumera√ß√£o Interna

```java
/**
 * Modos de aloca√ß√£o de GPU para VMs.
 */
public enum GpuAllocationMode {
    /**
     * Modo exclusivo: 1 GPU : 1 VM
     */
    EXCLUSIVE,
    
    /**
     * Modo compartilhado: 1 GPU : N VMs (futuro)
     */
    SHARED
}
```

#### Construtores

```java
/**
 * Construtor completo para GpuEdgeVM com suporte a GPU.
 * 
 * @param id Identificador √∫nico da VM
 * @param userId ID do usu√°rio/broker
 * @param mips Capacidade de processamento em MIPS
 * @param numberOfPes N√∫mero de cores de CPU
 * @param ram Mem√≥ria RAM em MB
 * @param bw Largura de banda em Mbps
 * @param size Armazenamento em MB
 * @param vmm Monitor de m√°quina virtual
 * @param cloudletScheduler Escalonador de tarefas CPU
 * @param gpuCloudletScheduler Escalonador de tarefas GPU
 * @param requiresGpu Indica se esta VM requer GPU
 */
public GpuEdgeVM(int id, int userId, double mips, int numberOfPes,
                 int ram, long bw, long size, String vmm,
                 CloudletScheduler cloudletScheduler,
                 GpuCloudletScheduler gpuCloudletScheduler,
                 boolean requiresGpu)

/**
 * Construtor alternativo sem escalonador GPU (para VMs sem GPU).
 * 
 * @param id Identificador √∫nico da VM
 * @param userId ID do usu√°rio/broker
 * @param mips Capacidade de processamento em MIPS
 * @param numberOfPes N√∫mero de cores de CPU
 * @param ram Mem√≥ria RAM em MB
 * @param bw Largura de banda em Mbps
 * @param size Armazenamento em MB
 * @param vmm Monitor de m√°quina virtual
 * @param cloudletScheduler Escalonador de tarefas CPU
 */
public GpuEdgeVM(int id, int userId, double mips, int numberOfPes,
                 int ram, long bw, long size, String vmm,
                 CloudletScheduler cloudletScheduler)
```

#### M√©todos

##### Getters e Setters GPU

```java
/**
 * Define a GPU alocada para esta VM.
 * @param gpu GPU a ser alocada
 */
public void setGpu(Gpu gpu)

/**
 * Retorna a GPU alocada para esta VM.
 * @return GPU alocada ou null
 */
public Gpu getGpu()

/**
 * Verifica se esta VM possui GPU alocada.
 * @return true se tem GPU alocada, false caso contr√°rio
 */
public boolean hasGpu()

/**
 * Verifica se esta VM requer GPU.
 * @return true se requer GPU, false caso contr√°rio
 */
public boolean requiresGpu()

/**
 * Define se esta VM requer GPU.
 * @param requiresGpu true se requer, false caso contr√°rio
 */
public void setRequiresGpu(boolean requiresGpu)

/**
 * Retorna o escalonador de tarefas GPU.
 * @return Escalonador GPU ou null
 */
public GpuCloudletScheduler getGpuCloudletScheduler()

/**
 * Define o escalonador de tarefas GPU.
 * @param scheduler Escalonador GPU
 */
public void setGpuCloudletScheduler(GpuCloudletScheduler scheduler)

/**
 * Retorna o modo de aloca√ß√£o GPU.
 * @return Modo de aloca√ß√£o (EXCLUSIVE ou SHARED)
 */
public GpuAllocationMode getGpuAllocationMode()

/**
 * Define o modo de aloca√ß√£o GPU.
 * @param mode Modo de aloca√ß√£o
 */
public void setGpuAllocationMode(GpuAllocationMode mode)
```

##### M√©todos de Execu√ß√£o GPU

```java
/**
 * Submete uma tarefa GPU para execu√ß√£o nesta VM.
 * Delega ao GpuCloudletScheduler.
 * 
 * @param gpuTask Tarefa GPU a ser executada
 * @return true se a tarefa foi aceita, false caso contr√°rio
 */
public boolean submitGpuTask(GpuTask gpuTask)

/**
 * Remove uma tarefa GPU da fila de execu√ß√£o.
 * 
 * @param gpuTask Tarefa GPU a ser removida
 * @return true se a tarefa foi removida, false caso contr√°rio
 */
public boolean removeGpuTask(GpuTask gpuTask)

/**
 * Retorna a lista de tarefas GPU em execu√ß√£o.
 * 
 * @return Lista de GpuTasks em execu√ß√£o
 */
public List<GpuTask> getRunningGpuTasks()

/**
 * Retorna o n√∫mero de tarefas GPU em execu√ß√£o.
 * 
 * @return N√∫mero de tarefas GPU ativas
 */
public int getNumberOfRunningGpuTasks()
```

##### M√©todos de M√©tricas GPU

```java
/**
 * Calcula a utiliza√ß√£o atual da GPU.
 * Retorna 0 se n√£o tiver GPU alocada.
 * 
 * @return Utiliza√ß√£o GPU em percentual (0-100%)
 */
public double getGpuUtilization()

/**
 * Calcula a utiliza√ß√£o combinada de CPU e GPU.
 * 
 * @return Utiliza√ß√£o m√©dia (CPU + GPU) / 2
 */
public double getCombinedUtilization()

/**
 * Retorna a mem√≥ria GPU dispon√≠vel nesta VM.
 * 
 * @return Mem√≥ria GPU dispon√≠vel em MB ou 0 se sem GPU
 */
public long getAvailableGpuMemory()

/**
 * Retorna a capacidade computacional GPU desta VM.
 * 
 * @return Capacidade em GFLOPS ou 0 se sem GPU
 */
public double getGpuGflops()
```

##### M√©todos de Reconfigura√ß√£o

```java
/**
 * Reconfigura a capacidade da GPU (se suportado).
 * Implementa√ß√£o futura para time-slicing din√¢mico.
 * 
 * @param newGflops Nova capacidade em GFLOPS
 */
public void reconfigureGpu(double newGflops)
```

---

### 1.7 Interface: GpuCloudletScheduler

**Pacote:** `edu.boun.edgecloudsim.edge_server`

**Prop√≥sito:** Define o contrato para escalonamento de tarefas GPU em uma VM.

**Implementa√ß√µes:** `GpuCloudletSchedulerTimeShared`, `GpuCloudletSchedulerSpaceShared` (futuro)

#### M√©todos

```java
/**
 * Inicializa o escalonador com uma GPU espec√≠fica.
 * 
 * @param gpu GPU a ser gerenciada pelo escalonador
 */
void initialize(Gpu gpu);

/**
 * Submete uma tarefa GPU para execu√ß√£o.
 * 
 * @param gpuTask Tarefa GPU a ser executada
 * @return true se a tarefa foi aceita, false caso contr√°rio
 */
boolean submitGpuTask(GpuTask gpuTask);

/**
 * Remove uma tarefa GPU da fila de execu√ß√£o.
 * 
 * @param gpuTask Tarefa a ser removida
 * @return true se a tarefa foi removida, false caso contr√°rio
 */
boolean removeGpuTask(GpuTask gpuTask);

/**
 * Atualiza o escalonamento das tarefas GPU.
 * Chamado periodicamente pelo simulador.
 * 
 * @param currentTime Tempo atual da simula√ß√£o
 * @return Pr√≥ximo tempo de evento ou Double.MAX_VALUE
 */
double updateGpuTaskProcessing(double currentTime);

/**
 * Retorna a lista de tarefas GPU atualmente em execu√ß√£o.
 * 
 * @return Lista de tarefas em execu√ß√£o
 */
List<GpuTask> getRunningGpuTasks();

/**
 * Retorna a lista de tarefas GPU aguardando execu√ß√£o.
 * 
 * @return Lista de tarefas em espera
 */
List<GpuTask> getWaitingGpuTasks();

/**
 * Retorna a lista de tarefas GPU completadas.
 * 
 * @return Lista de tarefas finalizadas
 */
List<GpuTask> getCompletedGpuTasks();

/**
 * Calcula a utiliza√ß√£o atual da GPU gerenciada.
 * 
 * @return Utiliza√ß√£o em percentual (0-100%)
 */
double getGpuUtilization();

/**
 * Verifica se h√° tarefas GPU em execu√ß√£o.
 * 
 * @return true se h√° tarefas em execu√ß√£o, false caso contr√°rio
 */
boolean hasRunningTasks();

/**
 * Retorna a GPU gerenciada por este escalonador.
 * 
 * @return GPU gerenciada
 */
Gpu getGpu();
```

---

### 1.8 Classe: GpuCloudletSchedulerTimeShared

**Pacote:** `edu.boun.edgecloudsim.edge_server`

**Prop√≥sito:** Implementa√ß√£o time-shared de escalonamento GPU (m√∫ltiplas tarefas compartilham GPU via time-slicing).

**Relacionamentos:**
- Implementa: `GpuCloudletScheduler`
- Usado por: `GpuEdgeVM`

#### Atributos

```java
/**
 * GPU gerenciada por este escalonador.
 * @visibility private
 * @type Gpu
 */
private Gpu gpu;

/**
 * Lista de tarefas GPU em execu√ß√£o.
 * @visibility private
 * @type List<GpuTask>
 */
private List<GpuTask> runningTasks;

/**
 * Lista de tarefas GPU aguardando execu√ß√£o.
 * @visibility private
 * @type List<GpuTask>
 */
private List<GpuTask> waitingTasks;

/**
 * Lista de tarefas GPU completadas.
 * @visibility private
 * @type List<GpuTask>
 */
private List<GpuTask> completedTasks;

/**
 * Mapa de tempo restante para cada tarefa (taskId -> remaining time).
 * @visibility private
 * @type Map<Integer, Double>
 */
private Map<Integer, Double> taskRemainingTimeMap;

/**
 * √öltimo tempo de atualiza√ß√£o do escalonamento.
 * @visibility private
 * @type double
 */
private double previousTime;
```

#### Construtores

```java
/**
 * Construtor padr√£o (GPU ser√° definida via initialize()).
 */
public GpuCloudletSchedulerTimeShared()

/**
 * Construtor com GPU especificada.
 * 
 * @param gpu GPU a ser gerenciada
 */
public GpuCloudletSchedulerTimeShared(Gpu gpu)
```

#### M√©todos

```java
/**
 * Inicializa o escalonador com uma GPU.
 * 
 * @param gpu GPU a ser gerenciada
 */
@Override
public void initialize(Gpu gpu)

/**
 * Submete uma tarefa GPU para execu√ß√£o.
 * Adiciona √† fila de running tasks e redistribui recursos.
 * 
 * @param gpuTask Tarefa GPU a ser executada
 * @return true sempre (time-shared aceita todas as tarefas)
 */
@Override
public boolean submitGpuTask(GpuTask gpuTask)

/**
 * Remove uma tarefa GPU da execu√ß√£o.
 * 
 * @param gpuTask Tarefa a ser removida
 * @return true se removida com sucesso
 */
@Override
public boolean removeGpuTask(GpuTask gpuTask)

/**
 * Atualiza o processamento das tarefas GPU.
 * Divide GFLOPS igualmente entre tarefas ativas.
 * 
 * @param currentTime Tempo atual da simula√ß√£o
 * @return Pr√≥ximo tempo de evento
 */
@Override
public double updateGpuTaskProcessing(double currentTime)

/**
 * Retorna a lista de tarefas em execu√ß√£o.
 * 
 * @return Lista de tarefas em execu√ß√£o
 */
@Override
public List<GpuTask> getRunningGpuTasks()

/**
 * Retorna a lista de tarefas aguardando.
 * 
 * @return Lista de tarefas em espera
 */
@Override
public List<GpuTask> getWaitingGpuTasks()

/**
 * Retorna a lista de tarefas completadas.
 * 
 * @return Lista de tarefas finalizadas
 */
@Override
public List<GpuTask> getCompletedGpuTasks()

/**
 * Calcula a utiliza√ß√£o da GPU baseada no n√∫mero de tarefas ativas.
 * 
 * @return Utiliza√ß√£o em percentual (0-100%)
 */
@Override
public double getGpuUtilization()

/**
 * Verifica se h√° tarefas em execu√ß√£o.
 * 
 * @return true se h√° tarefas em execu√ß√£o
 */
@Override
public boolean hasRunningTasks()

/**
 * Retorna a GPU gerenciada.
 * 
 * @return GPU gerenciada
 */
@Override
public Gpu getGpu()

/**
 * Redistribui os recursos GPU entre tarefas ativas.
 * Implementa time-slicing dividindo GFLOPS igualmente.
 */
private void redistributeGpuResources()

/**
 * Calcula o tempo restante de uma tarefa GPU.
 * 
 * @param gpuTask Tarefa GPU
 * @return Tempo restante em segundos
 */
private double calculateRemainingTime(GpuTask gpuTask)

/**
 * Finaliza uma tarefa GPU e move para completed tasks.
 * 
 * @param gpuTask Tarefa a ser finalizada
 */
private void finishGpuTask(GpuTask gpuTask)
```

---

### 1.9 Classe: GpuEdgeServerManager

**Pacote:** `edu.boun.edgecloudsim.edge_server`

**Prop√≥sito:** Gerenciador de infraestrutura edge com suporte a GPU.

**Relacionamentos:**
- Estende: `EdgeServerManager`
- Cria: `GpuEdgeHost`, `GpuEdgeVM`
- Usa: `GpuEdgeVmAllocationPolicy_Custom`

#### Atributos

```java
/**
 * Contador de IDs de hosts.
 * @visibility private
 * @type int
 */
private int hostIdCounter;

/**
 * Contador de IDs de VMs.
 * @visibility private
 * @type int
 */
private int vmIdCounter;
```

#### M√©todos

```java
/**
 * Inicializa o gerenciador de servidores GPU.
 */
@Override
public void initialize()

/**
 * Retorna a pol√≠tica de aloca√ß√£o de VMs para datacenters GPU.
 * 
 * @param list Lista de hosts do datacenter
 * @param dataCenterIndex √çndice do datacenter
 * @return Pol√≠tica de aloca√ß√£o GPU-aware
 */
@Override
public VmAllocationPolicy getVmAllocationPolicy(List<? extends Host> list, 
                                                 int dataCenterIndex)

/**
 * Inicia os datacenters edge com suporte a GPU.
 * L√™ configura√ß√µes do edge_devices.xml e cria GpuEdgeHosts.
 * 
 * @throws Exception se houver erro na cria√ß√£o dos datacenters
 */
@Override
public void startDatacenters() throws Exception

/**
 * Termina todos os datacenters edge.
 */
@Override
public void terminateDatacenters()

/**
 * Cria a lista de VMs edge com suporte a GPU.
 * L√™ configura√ß√µes do edge_devices.xml e aloca GPUs conforme necess√°rio.
 * 
 * @param brokerId ID do broker
 */
@Override
public void createVmList(int brokerId)

/**
 * Calcula a utiliza√ß√£o m√©dia (CPU + GPU) de todos os edge servers.
 * 
 * @return Utiliza√ß√£o m√©dia em percentual (0-100%)
 */
@Override
public double getAvgUtilization()

/**
 * Cria um datacenter edge com hosts GPU.
 * 
 * @param dataCenterIndex √çndice do datacenter
 * @param datacenterElement Elemento XML com configura√ß√µes
 * @return Datacenter criado
 * @throws Exception se houver erro na cria√ß√£o
 */
private Datacenter createGpuDatacenter(int dataCenterIndex, 
                                        Element datacenterElement) throws Exception

/**
 * Cria lista de hosts GPU a partir do XML.
 * 
 * @param datacenterElement Elemento XML com configura√ß√µes de hosts
 * @return Lista de GpuEdgeHosts criados
 */
private List<GpuEdgeHost> createGpuHosts(Element datacenterElement)

/**
 * Cria lista de GPUs a partir do XML.
 * 
 * @param hostElement Elemento XML com configura√ß√µes de GPUs
 * @return Lista de GPUs criadas
 */
private List<Gpu> createGpuList(Element hostElement)

/**
 * Cria lista de Processing Elements (CPU cores) a partir do XML.
 * 
 * @param hostElement Elemento XML com configura√ß√µes de PEs
 * @return Lista de PEs criados
 */
private List<Pe> createPeList(Element hostElement)
```

---

### 1.10 Classe: GpuEdgeVmAllocationPolicy_Custom

**Pacote:** `edu.boun.edgecloudsim.edge_server`

**Prop√≥sito:** Pol√≠tica de aloca√ß√£o de VMs com considera√ß√£o de recursos GPU.

**Relacionamentos:**
- Estende: `EdgeVmAllocationPolicy_Custom`
- Aloca: `GpuEdgeVM` em `GpuEdgeHost`

#### Atributos

```java
/**
 * √çndice do datacenter gerenciado por esta pol√≠tica.
 * @visibility private
 * @type int
 */
private int dataCenterIndex;
```

#### Construtores

```java
/**
 * Construtor da pol√≠tica de aloca√ß√£o GPU.
 * 
 * @param list Lista de hosts do datacenter
 * @param dataCenterIndex √çndice do datacenter
 */
public GpuEdgeVmAllocationPolicy_Custom(List<? extends Host> list, 
                                         int dataCenterIndex)
```

#### M√©todos

```java
/**
 * Aloca um host para uma VM considerando requisitos GPU.
 * Verifica disponibilidade de GPU antes de alocar a VM.
 * 
 * @param vm VM a ser alocada
 * @return true se a aloca√ß√£o foi bem-sucedida
 */
@Override
public boolean allocateHostForVm(Vm vm)

/**
 * Aloca um host espec√≠fico para uma VM considerando GPU.
 * 
 * @param vm VM a ser alocada
 * @param host Host onde a VM ser√° alocada
 * @return true se a aloca√ß√£o foi bem-sucedida
 */
@Override
public boolean allocateHostForVm(Vm vm, Host host)

/**
 * Desaloca o host de uma VM e libera a GPU associada.
 * 
 * @param vm VM a ser desalocada
 */
@Override
public void deallocateHostForVm(Vm vm)

/**
 * Encontra um host adequado para uma VM considerando recursos GPU.
 * 
 * @param vm VM para a qual buscar host
 * @return Host adequado ou null se nenhum dispon√≠vel
 */
private GpuEdgeHost findSuitableHostForVm(GpuEdgeVM vm)

/**
 * Verifica se um host pode hospedar uma VM com requisitos GPU.
 * 
 * @param host Host a ser verificado
 * @param vm VM com requisitos
 * @return true se o host pode hospedar a VM
 */
private boolean canHostVm(GpuEdgeHost host, GpuEdgeVM vm)

/**
 * Aloca GPU para uma VM em um host espec√≠fico.
 * 
 * @param host Host com GPUs dispon√≠veis
 * @param vm VM que receber√° a GPU
 * @return true se a aloca√ß√£o GPU foi bem-sucedida
 */
private boolean allocateGpuForVm(GpuEdgeHost host, GpuEdgeVM vm)
```

---

## 2. Diagramas UML Detalhados

### 2.1 Diagrama de Classes: Hierarquia GPU Completa

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                        <<Abstract>>                                         ‚îÇ
‚îÇ                     EdgeServerManager                                       ‚îÇ
‚îÇ  (edu.boun.edgecloudsim.edge_server)                                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  # localDatacenters: List<Datacenter>                                       ‚îÇ
‚îÇ  # vmList: List<List<EdgeVM>>                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  + initialize(): void                                                       ‚îÇ
‚îÇ  + getVmAllocationPolicy(...): VmAllocationPolicy [abstract]                ‚îÇ
‚îÇ  + startDatacenters(): void [abstract]                                      ‚îÇ
‚îÇ  + terminateDatacenters(): void [abstract]                                  ‚îÇ
‚îÇ  + createVmList(brokerId: int): void [abstract]                             ‚îÇ
‚îÇ  + getAvgUtilization(): double [abstract]                                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚ñ≥
                                ‚îÇ extends
                                ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     GpuEdgeServerManager                                    ‚îÇ
‚îÇ  (edu.boun.edgecloudsim.edge_server)                                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - hostIdCounter: int                                                       ‚îÇ
‚îÇ  - vmIdCounter: int                                                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  + initialize(): void                                                       ‚îÇ
‚îÇ  + getVmAllocationPolicy(...): VmAllocationPolicy                           ‚îÇ
‚îÇ  + startDatacenters(): void                                                 ‚îÇ
‚îÇ  + terminateDatacenters(): void                                             ‚îÇ
‚îÇ  + createVmList(brokerId: int): void                                        ‚îÇ
‚îÇ  + getAvgUtilization(): double                                              ‚îÇ
‚îÇ  - createGpuDatacenter(...): Datacenter                                     ‚îÇ
‚îÇ  - createGpuHosts(...): List<GpuEdgeHost>                                   ‚îÇ
‚îÇ  - createGpuList(...): List<Gpu>                                            ‚îÇ
‚îÇ  - createPeList(...): List<Pe>                                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚îÇ creates
                    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚ñº                  ‚ñº                    ‚ñº
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ   GpuEdgeHost      ‚îÇ  ‚îÇ   GpuEdgeVM    ‚îÇ  ‚îÇ GpuEdgeVmAllocation ‚îÇ
        ‚îÇ                    ‚îÇ  ‚îÇ                ‚îÇ  ‚îÇ   Policy_Custom     ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò




‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          <<CloudSim>>                ‚îÇ
‚îÇ            Host                      ‚îÇ
‚îÇ  (org.cloudbus.cloudsim)             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  # id: int                           ‚îÇ
‚îÇ  # ramProvisioner: RamProvisioner    ‚îÇ
‚îÇ  # bwProvisioner: BwProvisioner      ‚îÇ
‚îÇ  # storage: long                     ‚îÇ
‚îÇ  # peList: List<Pe>                  ‚îÇ
‚îÇ  # vmScheduler: VmScheduler          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  + vmCreate(vm: Vm): boolean         ‚îÇ
‚îÇ  + vmDestroy(vm: Vm): void           ‚îÇ
‚îÇ  + getVmList(): List<Vm>             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚ñ≥
                ‚îÇ extends
                ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           EdgeHost                   ‚îÇ
‚îÇ  (edu.boun.edgecloudsim.edge_server) ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - location: Location                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  + setPlace(location: Location)      ‚îÇ
‚îÇ  + getLocation(): Location           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚ñ≥
                ‚îÇ extends
                ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   GpuEdgeHost                                ‚îÇ
‚îÇ        (edu.boun.edgecloudsim.edge_server)                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - gpuList: List<Gpu>                                        ‚îÇ
‚îÇ  - gpuProvisioner: GpuProvisioner                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  + GpuEdgeHost(id, ..., gpuList, gpuProvisioner)             ‚îÇ
‚îÇ  + getGpuList(): List<Gpu>                                   ‚îÇ
‚îÇ  + getGpuProvisioner(): GpuProvisioner                       ‚îÇ
‚îÇ  + allocateGpuForVm(vm, gpu): boolean                        ‚îÇ
‚îÇ  + deallocateGpuForVm(vm): void                              ‚îÇ
‚îÇ  + hasAvailableGpu(): boolean                                ‚îÇ
‚îÇ  + getAvailableGpu(): Gpu                                    ‚îÇ
‚îÇ  + getAvgGpuUtilization(): double                            ‚îÇ
‚îÇ  + getTotalGpuMemory(): long                                 ‚îÇ
‚îÇ  + vmCreate(vm): boolean [override]                          ‚îÇ
‚îÇ  + vmDestroy(vm): void [override]                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚îÇ 1        contains       1..*
                    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>
                    ‚îÇ                                   ‚îÇ
                    ‚îÇ                                   ‚ñº
                    ‚îÇ                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ                    ‚îÇ            Gpu                 ‚îÇ
                    ‚îÇ                    ‚îÇ  (edu.boun.edgecloudsim.       ‚îÇ
                    ‚îÇ                    ‚îÇ   edge_server)                 ‚îÇ
                    ‚îÇ                    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                    ‚îÇ                    ‚îÇ  - id: int                     ‚îÇ
                    ‚îÇ                    ‚îÇ  - gpuType: String             ‚îÇ
                    ‚îÇ                    ‚îÇ  - cudaCores: int              ‚îÇ
                    ‚îÇ                    ‚îÇ  - gflops: double              ‚îÇ
                    ‚îÇ                    ‚îÇ  - gpuMemory: long             ‚îÇ
                    ‚îÇ                    ‚îÇ  - memoryBandwidth: double     ‚îÇ
                    ‚îÇ                    ‚îÇ  - utilization: double         ‚îÇ
                    ‚îÇ                    ‚îÇ  - usedMemory: long            ‚îÇ
                    ‚îÇ                    ‚îÇ  - allocatedVm: GpuEdgeVM      ‚îÇ
                    ‚îÇ                    ‚îÇ  - host: GpuEdgeHost           ‚îÇ
                    ‚îÇ                    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                    ‚îÇ                    ‚îÇ  + Gpu(id, type, cores, ...)   ‚îÇ
                    ‚îÇ                    ‚îÇ  + getId(): int                ‚îÇ
                    ‚îÇ                    ‚îÇ  + getGflops(): double         ‚îÇ
                    ‚îÇ                    ‚îÇ  + getUtilization(): double    ‚îÇ
                    ‚îÇ                    ‚îÇ  + isAvailable(): boolean      ‚îÇ
                    ‚îÇ                    ‚îÇ  + setAllocatedVm(vm)          ‚îÇ
                    ‚îÇ                    ‚îÇ  + allocateMemory(size): bool  ‚îÇ
                    ‚îÇ                    ‚îÇ  + calculateExecutionTime(...) ‚îÇ
                    ‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚îÇ uses                                ‚ñ≥
                    ‚îÇ                                     ‚îÇ manages
                    ‚ñº                                     ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ
‚îÇ    <<Interface>>                       ‚îÇ                ‚îÇ
‚îÇ    GpuProvisioner                      ‚îÇ                ‚îÇ
‚îÇ  (edu.boun.edgecloudsim.edge_server)   ‚îÇ                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§                ‚îÇ
‚îÇ  + allocateGpuForVm(vm, gpu): boolean  ‚îÇ                ‚îÇ
‚îÇ  + deallocateGpuForVm(vm): void        ‚îÇ                ‚îÇ
‚îÇ  + hasAvailableGpu(): boolean          ‚îÇ                ‚îÇ
‚îÇ  + getAvailableGpu(): Gpu              ‚îÇ                ‚îÇ
‚îÇ  + getGpuList(): List<Gpu>             ‚îÇ                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îÇ
                ‚ñ≥                                         ‚îÇ
                ‚îÇ implements                              ‚îÇ
                ‚îÇ                                         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ         GpuProvisionerSimple                       ‚îÇ    ‚îÇ
‚îÇ   (edu.boun.edgecloudsim.edge_server)              ‚îÇ    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îÇ
‚îÇ  - gpuList: List<Gpu>                              ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ  - vmGpuMap: Map<Integer, Gpu>                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  + GpuProvisionerSimple(gpuList)                   ‚îÇ
‚îÇ  + allocateGpuForVm(vm, gpu): boolean              ‚îÇ
‚îÇ  + deallocateGpuForVm(vm): void                    ‚îÇ
‚îÇ  + hasAvailableGpu(): boolean                      ‚îÇ
‚îÇ  + getAvailableGpu(): Gpu                          ‚îÇ
‚îÇ  + getAverageUtilization(): double                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò




‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      <<CloudSim>>              ‚îÇ
‚îÇ          Vm                    ‚îÇ
‚îÇ  (org.cloudbus.cloudsim)       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  # id: int                     ‚îÇ
‚îÇ  # userId: int                 ‚îÇ
‚îÇ  # mips: double                ‚îÇ
‚îÇ  # numberOfPes: int            ‚îÇ
‚îÇ  # ram: int                    ‚îÇ
‚îÇ  # bw: long                    ‚îÇ
‚îÇ  # size: long                  ‚îÇ
‚îÇ  # cloudletScheduler           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚ñ≥
                ‚îÇ extends
                ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          EdgeVM                ‚îÇ
‚îÇ  (edu.boun.edgecloudsim.       ‚îÇ
‚îÇ   edge_server)                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - type: VM_TYPES              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  + getVmType(): VM_TYPES       ‚îÇ
‚îÇ  + reconfigureMips(mips)       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚ñ≥
                ‚îÇ extends
                ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    GpuEdgeVM                             ‚îÇ
‚îÇ         (edu.boun.edgecloudsim.edge_server)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - allocatedGpu: Gpu                                     ‚îÇ
‚îÇ  - gpuCloudletScheduler: GpuCloudletScheduler            ‚îÇ
‚îÇ  - requiresGpu: boolean                                  ‚îÇ
‚îÇ  - gpuAllocationMode: GpuAllocationMode                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  + GpuEdgeVM(id, ..., gpuScheduler, requiresGpu)         ‚îÇ
‚îÇ  + setGpu(gpu): void                                     ‚îÇ
‚îÇ  + getGpu(): Gpu                                         ‚îÇ
‚îÇ  + hasGpu(): boolean                                     ‚îÇ
‚îÇ  + requiresGpu(): boolean                                ‚îÇ
‚îÇ  + getGpuCloudletScheduler(): GpuCloudletScheduler       ‚îÇ
‚îÇ  + submitGpuTask(task): boolean                          ‚îÇ
‚îÇ  + getGpuUtilization(): double                           ‚îÇ
‚îÇ  + getAvailableGpuMemory(): long                         ‚îÇ
‚îÇ  + reconfigureGpu(gflops): void                          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  <<enumeration>>                                         ‚îÇ
‚îÇ  + GpuAllocationMode                                     ‚îÇ
‚îÇ    - EXCLUSIVE                                           ‚îÇ
‚îÇ    - SHARED                                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚îÇ 1     has     0..1
                    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>
                    ‚îÇ                    ‚îÇ
                    ‚îÇ                    ‚ñº
                    ‚îÇ                  [Gpu]
                    ‚îÇ
                    ‚îÇ 1      uses      1
                    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>
                    ‚îÇ                                         ‚îÇ
                    ‚ñº                                         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      <<Interface>>                       ‚îÇ  ‚îÇ    <<Interface>>               ‚îÇ
‚îÇ      GpuCloudletScheduler                ‚îÇ  ‚îÇ    GpuProvisioner              ‚îÇ
‚îÇ  (edu.boun.edgecloudsim.edge_server)     ‚îÇ  ‚îÇ                                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ  + initialize(gpu): void                 ‚îÇ
‚îÇ  + submitGpuTask(task): boolean          ‚îÇ
‚îÇ  + removeGpuTask(task): boolean          ‚îÇ
‚îÇ  + updateGpuTaskProcessing(time): double ‚îÇ
‚îÇ  + getRunningGpuTasks(): List<GpuTask>   ‚îÇ
‚îÇ  + getGpuUtilization(): double           ‚îÇ
‚îÇ  + getGpu(): Gpu                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚ñ≥
                ‚îÇ implements
                ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       GpuCloudletSchedulerTimeShared                  ‚îÇ
‚îÇ   (edu.boun.edgecloudsim.edge_server)                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - gpu: Gpu                                           ‚îÇ
‚îÇ  - runningTasks: List<GpuTask>                        ‚îÇ
‚îÇ  - waitingTasks: List<GpuTask>                        ‚îÇ
‚îÇ  - completedTasks: List<GpuTask>                      ‚îÇ
‚îÇ  - taskRemainingTimeMap: Map<Integer, Double>         ‚îÇ
‚îÇ  - previousTime: double                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  + GpuCloudletSchedulerTimeShared()                   ‚îÇ
‚îÇ  + GpuCloudletSchedulerTimeShared(gpu)                ‚îÇ
‚îÇ  + initialize(gpu): void                              ‚îÇ
‚îÇ  + submitGpuTask(task): boolean                       ‚îÇ
‚îÇ  + updateGpuTaskProcessing(time): double              ‚îÇ
‚îÇ  + getGpuUtilization(): double                        ‚îÇ
‚îÇ  - redistributeGpuResources(): void                   ‚îÇ
‚îÇ  - finishGpuTask(task): void                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚îÇ manages
                    ‚îÇ 1      *
                    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>
                    ‚îÇ                  ‚îÇ
                    ‚ñº                  ‚ñº
                  [Gpu]         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                ‚îÇ         GpuTask                  ‚îÇ
                                ‚îÇ  (edu.boun.edgecloudsim.         ‚îÇ
                                ‚îÇ   edge_client)                   ‚îÇ
                                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò




‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      <<CloudSim>>              ‚îÇ
‚îÇ        Cloudlet                ‚îÇ
‚îÇ  (org.cloudbus.cloudsim)       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  # cloudletId: int             ‚îÇ
‚îÇ  # cloudletLength: long        ‚îÇ
‚îÇ  # pesNumber: int              ‚îÇ
‚îÇ  # fileSize: long              ‚îÇ
‚îÇ  # outputSize: long            ‚îÇ
‚îÇ  # utilizationModelCpu         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚ñ≥
                ‚îÇ extends
                ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            Task                ‚îÇ
‚îÇ  (edu.boun.edgecloudsim.       ‚îÇ
‚îÇ   edge_client)                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - submittedLocation: Location ‚îÇ
‚îÇ  - creationTime: double        ‚îÇ
‚îÇ  - type: int                   ‚îÇ
‚îÇ  - mobileDeviceId: int         ‚îÇ
‚îÇ  - hostIndex: int              ‚îÇ
‚îÇ  - vmIndex: int                ‚îÇ
‚îÇ  - datacenterId: int           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  + Task(deviceId, id, ...)     ‚îÇ
‚îÇ  + setSubmittedLocation(loc)   ‚îÇ
‚îÇ  + getMobileDeviceId(): int    ‚îÇ
‚îÇ  + getTaskType(): int          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚ñ≥
                ‚îÇ extends
                ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    GpuTask                               ‚îÇ
‚îÇ         (edu.boun.edgecloudsim.edge_client)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - gpuLength: long                                       ‚îÇ
‚îÇ  - gpuInputData: long                                    ‚îÇ
‚îÇ  - gpuOutputData: long                                   ‚îÇ
‚îÇ  - requiredGpuMemory: long                               ‚îÇ
‚îÇ  - expectedGpuUtilization: double                        ‚îÇ
‚îÇ  - executedGpuId: int                                    ‚îÇ
‚îÇ  - gpuDataTransferTime: double                           ‚îÇ
‚îÇ  - gpuExecutionTime: double                              ‚îÇ
‚îÇ  - gpuDataBackTime: double                               ‚îÇ
‚îÇ  - actualGpuUtilization: double                          ‚îÇ
‚îÇ  - gpuStartTime: double                                  ‚îÇ
‚îÇ  - gpuFinishTime: double                                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  + GpuTask(deviceId, id, ..., gpuLength, ...)            ‚îÇ
‚îÇ  + getGpuLength(): long                                  ‚îÇ
‚îÇ  + getGpuInputData(): long                               ‚îÇ
‚îÇ  + getRequiredGpuMemory(): long                          ‚îÇ
‚îÇ  + getGpuExecutionTime(): double                         ‚îÇ
‚îÇ  + setGpuDataTransferTime(time): void                    ‚îÇ
‚îÇ  + setActualGpuUtilization(util): void                   ‚îÇ
‚îÇ  + getTotalGpuTime(): double                             ‚îÇ
‚îÇ  + requiresGpu(): boolean                                ‚îÇ
‚îÇ  + getGpuIntensity(): double                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò




‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           <<CloudSim>>                                   ‚îÇ
‚îÇ           VmAllocationPolicy                             ‚îÇ
‚îÇ    (org.cloudbus.cloudsim)                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  # hostList: List<Host>                                  ‚îÇ
‚îÇ  # vmTable: Map<String, Host>                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  + allocateHostForVm(vm): boolean [abstract]             ‚îÇ
‚îÇ  + deallocateHostForVm(vm): void [abstract]              ‚îÇ
‚îÇ  + getHost(vm): Host                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚ñ≥
                ‚îÇ extends
                ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        EdgeVmAllocationPolicy_Custom                     ‚îÇ
‚îÇ   (edu.boun.edgecloudsim.edge_server)                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - dataCenterIndex: int                                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  + allocateHostForVm(vm): boolean                        ‚îÇ
‚îÇ  + deallocateHostForVm(vm): void                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚ñ≥
                ‚îÇ extends
                ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        GpuEdgeVmAllocationPolicy_Custom                  ‚îÇ
‚îÇ   (edu.boun.edgecloudsim.edge_server)                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - dataCenterIndex: int                                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  + GpuEdgeVmAllocationPolicy_Custom(list, index)         ‚îÇ
‚îÇ  + allocateHostForVm(vm): boolean [override]             ‚îÇ
‚îÇ  + deallocateHostForVm(vm): void [override]              ‚îÇ
‚îÇ  - findSuitableHostForVm(vm): GpuEdgeHost                ‚îÇ
‚îÇ  - canHostVm(host, vm): boolean                          ‚îÇ
‚îÇ  - allocateGpuForVm(host, vm): boolean                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

### 2.2 Diagrama de Pacotes

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ               edu.boun.edgecloudsim.edge_server                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Classes:                                                          ‚îÇ
‚îÇ    ‚Ä¢ EdgeServerManager (abstract)                                  ‚îÇ
‚îÇ    ‚Ä¢ GpuEdgeServerManager                                          ‚îÇ
‚îÇ    ‚Ä¢ EdgeHost                                                      ‚îÇ
‚îÇ    ‚Ä¢ GpuEdgeHost                                                   ‚îÇ
‚îÇ    ‚Ä¢ EdgeVM                                                        ‚îÇ
‚îÇ    ‚Ä¢ GpuEdgeVM                                                     ‚îÇ
‚îÇ    ‚Ä¢ EdgeVmAllocationPolicy_Custom                                 ‚îÇ
‚îÇ    ‚Ä¢ GpuEdgeVmAllocationPolicy_Custom                              ‚îÇ
‚îÇ    ‚Ä¢ Gpu                                                           ‚îÇ
‚îÇ                                                                    ‚îÇ
‚îÇ  Interfaces:                                                       ‚îÇ
‚îÇ    ‚Ä¢ GpuProvisioner                                                ‚îÇ
‚îÇ    ‚Ä¢ GpuCloudletScheduler                                          ‚îÇ
‚îÇ                                                                    ‚îÇ
‚îÇ  Implementa√ß√µes:                                                   ‚îÇ
‚îÇ    ‚Ä¢ GpuProvisionerSimple                                          ‚îÇ
‚îÇ    ‚Ä¢ GpuCloudletSchedulerTimeShared                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ
                        ‚îÇ uses
                        ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ               edu.boun.edgecloudsim.edge_client                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Classes:                                                          ‚îÇ
‚îÇ    ‚Ä¢ Task                                                          ‚îÇ
‚îÇ    ‚Ä¢ GpuTask                                                       ‚îÇ
‚îÇ    ‚Ä¢ MobileDeviceManager (abstract)                                ‚îÇ
‚îÇ    ‚Ä¢ DefaultMobileDeviceManager                                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ
                        ‚îÇ uses
                        ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ               edu.boun.edgecloudsim.core                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Classes:                                                          ‚îÇ
‚îÇ    ‚Ä¢ SimManager                                                    ‚îÇ
‚îÇ    ‚Ä¢ SimSettings                                                   ‚îÇ
‚îÇ                                                                    ‚îÇ
‚îÇ  Interfaces:                                                       ‚îÇ
‚îÇ    ‚Ä¢ ScenarioFactory                                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ
                        ‚îÇ depends on
                        ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  org.cloudbus.cloudsim                             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Classes:                                                          ‚îÇ
‚îÇ    ‚Ä¢ Host                                                          ‚îÇ
‚îÇ    ‚Ä¢ Vm                                                            ‚îÇ
‚îÇ    ‚Ä¢ Cloudlet                                                      ‚îÇ
‚îÇ    ‚Ä¢ Datacenter                                                    ‚îÇ
‚îÇ    ‚Ä¢ VmAllocationPolicy                                            ‚îÇ
‚îÇ    ‚Ä¢ CloudletScheduler                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

### 2.3 Diagrama de Relacionamentos

```
                  GpuEdgeServerManager
                          ‚îÇ
                          ‚îÇ creates
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ                   ‚îÇ               ‚îÇ
                ‚ñº                   ‚ñº               ‚ñº
         GpuEdgeHost         GpuEdgeVM    GpuEdgeVmAllocation
                ‚îÇ                ‚îÇ          Policy_Custom
                ‚îÇ contains       ‚îÇ has             ‚îÇ
                ‚îÇ 1..*           ‚îÇ 0..1            ‚îÇ uses
                ‚ñº                ‚ñº                 ‚îÇ
              Gpu ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                  ‚îÇ
                ‚îÇ                                  ‚îÇ
                ‚îÇ managed by                       ‚îÇ
                ‚ñº                                  ‚îÇ
          GpuProvisioner ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚ñ≥
                ‚îÇ implemented by
                ‚îÇ
          GpuProvisionerSimple


         GpuEdgeVM
              ‚îÇ
              ‚îÇ uses
              ‚ñº
     GpuCloudletScheduler ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ schedules ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ GpuTask
              ‚ñ≥                                      ‚îÇ
              ‚îÇ implemented by                       ‚îÇ extends
              ‚îÇ                                      ‚îÇ
    GpuCloudletScheduler                            Task
        TimeShared                                   ‚îÇ extends
                                                     ‚îÇ
                                                  Cloudlet
```

---

## 3. Contratos de Interfaces

### 3.1 Interface: GpuProvisioner

**Objetivo:** Definir contrato para provisionamento de GPUs a VMs.

**JavaDoc Completo:**

```java
package edu.boun.edgecloudsim.edge_server;

import java.util.List;

/**
 * Interface que define o contrato para provisionamento de GPUs a VMs.
 * 
 * <p>Esta interface especifica os m√©todos necess√°rios para gerenciar a aloca√ß√£o
 * e desaloca√ß√£o de recursos GPU em hosts edge. Implementa√ß√µes desta interface
 * s√£o respons√°veis por:
 * <ul>
 *   <li>Rastrear disponibilidade de GPUs</li>
 *   <li>Alocar GPUs para VMs com base em requisitos</li>
 *   <li>Desalocar GPUs quando VMs s√£o destru√≠das</li>
 *   <li>Fornecer informa√ß√µes sobre utiliza√ß√£o de GPU</li>
 * </ul>
 * 
 * <p><b>Pol√≠ticas de Provisionamento:</b>
 * <ul>
 *   <li><b>Exclusive Mode:</b> 1 GPU : 1 VM (implementa√ß√£o atual)</li>
 *   <li><b>Shared Mode:</b> 1 GPU : N VMs (implementa√ß√£o futura)</li>
 * </ul>
 * 
 * <p><b>Exemplo de Uso:</b>
 * <pre>
 * GpuProvisioner provisioner = new GpuProvisionerSimple(gpuList);
 * if (provisioner.hasAvailableGpu()) {
 *     Gpu gpu = provisioner.getAvailableGpu();
 *     if (provisioner.allocateGpuForVm(vm, gpu)) {
 *         System.out.println("GPU " + gpu.getId() + " alocada para VM " + vm.getId());
 *     }
 * }
 * </pre>
 * 
 * @author Pabllo Borges Cardoso
 * @version 1.0
 * @since GpuEdgeCloudSim 1.0
 * 
 * @see GpuProvisionerSimple
 * @see GpuEdgeHost
 * @see Gpu
 */
public interface GpuProvisioner {
    
    /**
     * Aloca uma GPU espec√≠fica para uma VM.
     * 
     * <p>Este m√©todo tenta alocar a GPU especificada para a VM fornecida.
     * A aloca√ß√£o s√≥ √© bem-sucedida se a GPU estiver dispon√≠vel (n√£o alocada).
     * 
     * <p><b>Pr√©-condi√ß√µes:</b>
     * <ul>
     *   <li>A GPU deve existir na lista gerenciada pelo provisioner</li>
     *   <li>A GPU deve estar dispon√≠vel (isAvailable() == true)</li>
     *   <li>A VM n√£o deve ter GPU previamente alocada</li>
     * </ul>
     * 
     * <p><b>P√≥s-condi√ß√µes (se bem-sucedido):</b>
     * <ul>
     *   <li>GPU.allocatedVm aponta para a VM</li>
     *   <li>GPU.isAvailable() retorna false</li>
     *   <li>Mapeamento VM‚ÜíGPU √© registrado</li>
     * </ul>
     * 
     * @param vm  VM que receber√° a GPU (n√£o-null)
     * @param gpu GPU a ser alocada (n√£o-null, dispon√≠vel)
     * @return true se a aloca√ß√£o foi bem-sucedida, false caso contr√°rio
     * 
     * @throws NullPointerException se vm ou gpu forem null
     */
    boolean allocateGpuForVm(GpuEdgeVM vm, Gpu gpu);
    
    /**
     * Desaloca a GPU de uma VM, tornando-a dispon√≠vel para outras VMs.
     * 
     * <p>Remove a associa√ß√£o entre VM e GPU, resetando o estado da GPU
     * e removendo-a do mapeamento interno.
     * 
     * <p><b>P√≥s-condi√ß√µes:</b>
     * <ul>
     *   <li>GPU.allocatedVm = null</li>
     *   <li>GPU.utilization = 0</li>
     *   <li>GPU.usedMemory = 0</li>
     *   <li>GPU.isAvailable() retorna true</li>
     *   <li>Mapeamento VM‚ÜíGPU √© removido</li>
     * </ul>
     * 
     * @param vm VM da qual a GPU ser√° desalocada (n√£o-null)
     * 
     * @throws NullPointerException se vm for null
     */
    void deallocateGpuForVm(GpuEdgeVM vm);
    
    /**
     * Verifica se h√° pelo menos uma GPU dispon√≠vel no pool.
     * 
     * <p>Uma GPU √© considerada dispon√≠vel se n√£o estiver alocada para nenhuma VM.
     * 
     * @return true se existe pelo menos uma GPU dispon√≠vel, false caso contr√°rio
     */
    boolean hasAvailableGpu();
    
    /**
     * Retorna uma GPU dispon√≠vel do pool gerenciado.
     * 
     * <p>A estrat√©gia de sele√ß√£o depende da implementa√ß√£o:
     * <ul>
     *   <li><b>First-Fit:</b> Primeira GPU dispon√≠vel encontrada</li>
     *   <li><b>Best-Fit:</b> GPU com capacidade mais pr√≥xima do requisito</li>
     *   <li><b>Least-Loaded:</b> GPU com menor utiliza√ß√£o atual</li>
     * </ul>
     * 
     * <p><b>Nota:</b> Este m√©todo n√£o realiza aloca√ß√£o automaticamente.
     * Use {@link #allocateGpuForVm(GpuEdgeVM, Gpu)} ap√≥s obter a GPU.
     * 
     * @return GPU dispon√≠vel ou null se n√£o houver nenhuma dispon√≠vel
     */
    Gpu getAvailableGpu();
    
    /**
     * Retorna uma GPU dispon√≠vel com mem√≥ria suficiente para um requisito.
     * 
     * <p>Busca uma GPU que esteja dispon√≠vel E tenha pelo menos a quantidade
     * de mem√≥ria especificada livre.
     * 
     * @param requiredMemory Mem√≥ria m√≠nima necess√°ria em MB (>= 0)
     * @return GPU dispon√≠vel com mem√≥ria suficiente ou null
     * 
     * @throws IllegalArgumentException se requiredMemory < 0
     */
    Gpu getAvailableGpuWithMemory(long requiredMemory);
    
    /**
     * Retorna a lista completa de GPUs gerenciadas por este provisioner.
     * 
     * <p>A lista retornada inclui tanto GPUs dispon√≠veis quanto alocadas.
     * 
     * @return Lista imut√°vel de todas as GPUs gerenciadas
     */
    List<Gpu> getGpuList();
    
    /**
     * Retorna a lista de GPUs atualmente dispon√≠veis (n√£o alocadas).
     * 
     * @return Lista de GPUs dispon√≠veis (possivelmente vazia)
     */
    List<Gpu> getAvailableGpuList();
    
    /**
     * Retorna a lista de GPUs atualmente alocadas a VMs.
     * 
     * @return Lista de GPUs alocadas (possivelmente vazia)
     */
    List<Gpu> getAllocatedGpuList();
}
```

---

### 3.2 Interface: GpuCloudletScheduler

**Objetivo:** Definir contrato para escalonamento de tarefas GPU em uma VM.

**JavaDoc Completo:**

```java
package edu.boun.edgecloudsim.edge_server;

import edu.boun.edgecloudsim.edge_client.GpuTask;
import java.util.List;

/**
 * Interface que define o contrato para escalonamento de tarefas GPU em uma VM.
 * 
 * <p>Esta interface especifica os m√©todos necess√°rios para gerenciar a execu√ß√£o
 * de tarefas GPU em uma √∫nica GPU alocada a uma VM. Implementa√ß√µes desta interface
 * s√£o respons√°veis por:
 * <ul>
 *   <li>Aceitar submiss√£o de novas tarefas GPU</li>
 *   <li>Escalonar execu√ß√£o de tarefas (space-shared ou time-shared)</li>
 *   <li>Atualizar progresso de tarefas durante a simula√ß√£o</li>
 *   <li>Calcular utiliza√ß√£o da GPU</li>
 *   <li>Gerenciar filas de tarefas (running, waiting, completed)</li>
 * </ul>
 * 
 * <p><b>Pol√≠ticas de Escalonamento:</b>
 * <ul>
 *   <li><b>Time-Shared:</b> M√∫ltiplas tarefas compartilham GPU via time-slicing
 *       (implementa√ß√£o atual: {@link GpuCloudletSchedulerTimeShared})</li>
 *   <li><b>Space-Shared:</b> Uma tarefa por vez, outras aguardam em fila
 *       (implementa√ß√£o futura: GpuCloudletSchedulerSpaceShared)</li>
 * </ul>
 * 
 * <p><b>Fluxo de Execu√ß√£o:</b>
 * <pre>
 * 1. submitGpuTask() ‚Üí Tarefa entra no sistema
 * 2. updateGpuTaskProcessing() ‚Üí Atualiza progresso periodicamente
 * 3. Tarefa completa ‚Üí Move para completed tasks
 * 4. getCompletedGpuTasks() ‚Üí Recupera tarefas finalizadas
 * </pre>
 * 
 * <p><b>Exemplo de Uso:</b>
 * <pre>
 * GpuCloudletScheduler scheduler = new GpuCloudletSchedulerTimeShared(gpu);
 * GpuTask task = new GpuTask(...);
 * 
 * if (scheduler.submitGpuTask(task)) {
 *     System.out.println("Tarefa " + task.getCloudletId() + " aceita");
 *     
 *     // Durante simula√ß√£o
 *     double nextEventTime = scheduler.updateGpuTaskProcessing(CloudSim.clock());
 *     
 *     // Recuperar tarefas completadas
 *     List<GpuTask> completed = scheduler.getCompletedGpuTasks();
 * }
 * </pre>
 * 
 * @author Pabllo Borges Cardoso
 * @version 1.0
 * @since GpuEdgeCloudSim 1.0
 * 
 * @see GpuCloudletSchedulerTimeShared
 * @see GpuTask
 * @see GpuEdgeVM
 */
public interface GpuCloudletScheduler {
    
    /**
     * Inicializa o escalonador com uma GPU espec√≠fica.
     * 
     * <p>Este m√©todo deve ser chamado antes de qualquer opera√ß√£o de escalonamento.
     * Define a GPU que ser√° gerenciada por este escalonador.
     * 
     * <p><b>Pr√©-condi√ß√µes:</b>
     * <ul>
     *   <li>GPU n√£o deve ser null</li>
     *   <li>M√©todo deve ser chamado apenas uma vez</li>
     * </ul>
     * 
     * @param gpu GPU a ser gerenciada pelo escalonador (n√£o-null)
     * 
     * @throws NullPointerException se gpu for null
     * @throws IllegalStateException se j√° foi inicializado
     */
    void initialize(Gpu gpu);
    
    /**
     * Submete uma tarefa GPU para execu√ß√£o.
     * 
     * <p>A tarefa √© adicionada ao escalonador e seu processamento √© iniciado
     * conforme a pol√≠tica de escalonamento implementada.
     * 
     * <p><b>Comportamento por Pol√≠tica:</b>
     * <ul>
     *   <li><b>Time-Shared:</b> Tarefa sempre aceita, GFLOPS redistribu√≠do</li>
     *   <li><b>Space-Shared:</b> Tarefa aceita s√≥ se GPU livre, sen√£o enfileira</li>
     * </ul>
     * 
     * <p><b>Pr√©-condi√ß√µes:</b>
     * <ul>
     *   <li>Escalonador deve estar inicializado</li>
     *   <li>gpuTask n√£o deve ser null</li>
     *   <li>gpuTask.requiresGpu() deve retornar true</li>
     * </ul>
     * 
     * @param gpuTask Tarefa GPU a ser executada (n√£o-null)
     * @return true se a tarefa foi aceita, false caso contr√°rio
     * 
     * @throws NullPointerException se gpuTask for null
     * @throws IllegalStateException se escalonador n√£o inicializado
     */
    boolean submitGpuTask(GpuTask gpuTask);
    
    /**
     * Remove uma tarefa GPU da fila de execu√ß√£o.
     * 
     * <p>Cancela a execu√ß√£o de uma tarefa antes de sua conclus√£o.
     * A tarefa √© removida das filas (running ou waiting) mas n√£o √©
     * adicionada √† fila completed.
     * 
     * @param gpuTask Tarefa a ser removida (n√£o-null)
     * @return true se a tarefa foi removida com sucesso, false se n√£o encontrada
     * 
     * @throws NullPointerException se gpuTask for null
     */
    boolean removeGpuTask(GpuTask gpuTask);
    
    /**
     * Atualiza o processamento das tarefas GPU.
     * 
     * <p>M√©todo chamado periodicamente pelo simulador para avan√ßar o progresso
     * das tarefas em execu√ß√£o. Calcula quanto trabalho foi realizado desde a
     * √∫ltima atualiza√ß√£o e move tarefas completadas para a fila appropriada.
     * 
     * <p><b>Responsabilidades:</b>
     * <ul>
     *   <li>Calcular delta de tempo: currentTime - previousTime</li>
     *   <li>Atualizar progresso de cada tarefa em execu√ß√£o</li>
     *   <li>Identificar tarefas completadas</li>
     *   <li>Mover tarefas completadas para fila completed</li>
     *   <li>Atualizar utiliza√ß√£o da GPU</li>
     *   <li>Retornar pr√≥ximo tempo de evento</li>
     * </ul>
     * 
     * @param currentTime Tempo atual da simula√ß√£o em segundos
     * @return Pr√≥ximo tempo onde ocorrer√° conclus√£o de tarefa,
     *         ou Double.MAX_VALUE se n√£o h√° tarefas em execu√ß√£o
     * 
     * @throws IllegalArgumentException se currentTime < previousTime
     */
    double updateGpuTaskProcessing(double currentTime);
    
    /**
     * Retorna a lista de tarefas GPU atualmente em execu√ß√£o.
     * 
     * <p>Tarefas nesta lista est√£o ativamente consumindo recursos da GPU.
     * 
     * @return Lista de tarefas em execu√ß√£o (n√£o-null, possivelmente vazia)
     */
    List<GpuTask> getRunningGpuTasks();
    
    /**
     * Retorna a lista de tarefas GPU aguardando execu√ß√£o.
     * 
     * <p>Aplic√°vel principalmente para pol√≠ticas space-shared onde tarefas
     * podem ficar enfileiradas aguardando libera√ß√£o da GPU.
     * 
     * @return Lista de tarefas em espera (n√£o-null, possivelmente vazia)
     */
    List<GpuTask> getWaitingGpuTasks();
    
    /**
     * Retorna a lista de tarefas GPU completadas.
     * 
     * <p>Tarefas nesta lista finalizaram sua execu√ß√£o e aguardam coleta
     * pelo gerenciador de tarefas.
     * 
     * @return Lista de tarefas finalizadas (n√£o-null, possivelmente vazia)
     */
    List<GpuTask> getCompletedGpuTasks();
    
    /**
     * Calcula a utiliza√ß√£o atual da GPU gerenciada.
     * 
     * <p>F√≥rmula de c√°lculo varia por implementa√ß√£o:
     * <ul>
     *   <li><b>Time-Shared:</b> min(100, (numTasks / maxConcurrentTasks) * 100)</li>
     *   <li><b>Space-Shared:</b> 100 se tem tarefa, 0 caso contr√°rio</li>
     * </ul>
     * 
     * @return Utiliza√ß√£o em percentual (0-100%)
     */
    double getGpuUtilization();
    
    /**
     * Verifica se h√° tarefas GPU em execu√ß√£o.
     * 
     * <p>√ötil para determinar se a GPU est√° ociosa.
     * 
     * @return true se h√° pelo menos uma tarefa em execu√ß√£o, false caso contr√°rio
     */
    boolean hasRunningTasks();
    
    /**
     * Retorna a GPU gerenciada por este escalonador.
     * 
     * @return GPU gerenciada ou null se n√£o inicializado
     */
    Gpu getGpu();
}
```

---

## 4. Diagramas de Sequ√™ncia

### 4.1 Fluxo: Cria√ß√£o de Infraestrutura GPU

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇMainApp ‚îÇ    ‚îÇSimManager  ‚îÇ    ‚îÇGpuEdgeServerManager  ‚îÇ   ‚îÇGpuEdgeHost  ‚îÇ    ‚îÇGpuEdgeVM  ‚îÇ  ‚îÇGpu   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ new SimManager(factory)              ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                     ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ factory.getEdgeServerManager()             ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ    new GpuEdgeServerManager()              ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ startSimulation()                    ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                     ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ startDatacenters()  ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ [L√™ edge_devices.xml]                  ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ          ‚îÇ           ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ createGpuHosts()     ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ          ‚îÇ           ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ          ‚îÇ createGpuList()             ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ          ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ          ‚îÇ           ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ          ‚îÇ           ‚îÇ                 ‚îÇ new Gpu()  ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ          ‚îÇ           ‚îÇ                 ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ          ‚îÇ           ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ          ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ          ‚îÇ           ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ          ‚îÇ new GpuEdgeHost(gpuList)    ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ          ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ          ‚îÇ           ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ createGpuDatacenter()‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ          ‚îÇ           ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ createVmList(brokerId)                     ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ [L√™ edge_devices.xml]                  ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ          ‚îÇ           ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ  new GpuEdgeVM()‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ getAvailableGpu()    ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ allocateGpuForVm(vm, gpu)              ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ                 ‚îÇ setAllocatedVm()
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ                 ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ  setGpu(gpu)    ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ                ‚îÇ                     ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
    ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                     ‚îÇ                      ‚îÇ                 ‚îÇ            ‚îÇ
```

**Descri√ß√£o:**
1. **MainApp** cria **SimManager** com factory
2. **SimManager** obt√©m **GpuEdgeServerManager** via factory
3. **SimManager** chama **startDatacenters()**
4. **GpuEdgeServerManager** l√™ **edge_devices.xml**
5. Para cada host, cria lista de **Gpu** objects
6. Cria **GpuEdgeHost** com lista de GPUs
7. **SimManager** chama **createVmList()**
8. Para cada VM que requer GPU:
   - Cria **GpuEdgeVM**
   - Obt√©m GPU dispon√≠vel
   - Aloca GPU para a VM

---

### 4.2 Fluxo: Aloca√ß√£o de GPU para VM

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇGpuEdgeVmAllocation       ‚îÇ   ‚îÇGpuEdgeHost            ‚îÇ   ‚îÇGpuProvisioner‚îÇ  ‚îÇGpu   ‚îÇ
‚îÇPolicy_Custom             ‚îÇ   ‚îÇ                       ‚îÇ   ‚îÇ              ‚îÇ  ‚îÇ      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò
           ‚îÇ                               ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ allocateHostForVm(vm)         ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ [Verifica se VM    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ  requer GPU]       ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ                               ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ findSuitableHostForVm(vm)     ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ hasAvailableGpu()  ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ hasAvailableGpu()    ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ [Verifica    ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ  GPUs        ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ  dispon√≠veis]‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ      ‚îÇ       ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ  [Host adequado encontrado]   ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ                               ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ allocateGpuForVm(host, vm)    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ getAvailableGpu()  ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ getAvailableGpu()    ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ [Retorna 1¬™  ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ  GPU livre]  ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ      ‚îÇ       ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ allocateGpuForVm(vm, gpu)                 ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ allocateGpuForVm(vm, gpu)           ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ isAvailable()‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ  true        ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ setAllocatedVm(vm)
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ  void        ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ  true                ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ  true              ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ vm.setGpu(gpu)     ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ          ‚îÇ         ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ          ‚îÇ                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ  true                         ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ                               ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ host.vmCreate(vm)             ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ                               ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                      ‚îÇ              ‚îÇ
           ‚îÇ  true                         ‚îÇ                      ‚îÇ              ‚îÇ
```

**Descri√ß√£o:**
1. **GpuEdgeVmAllocationPolicy_Custom** recebe requisi√ß√£o de aloca√ß√£o
2. Verifica se a VM requer GPU
3. Busca host adequado com **findSuitableHostForVm()**
4. Verifica se o host tem GPU dispon√≠vel via **hasAvailableGpu()**
5. Obt√©m GPU dispon√≠vel via **getAvailableGpu()**
6. Aloca GPU para VM via **allocateGpuForVm()**
7. **GpuProvisioner** verifica disponibilidade e marca GPU como alocada
8. VM √© criada no host com GPU alocada

---

### 4.3 Fluxo: Execu√ß√£o de GpuTask

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇMobileDevice      ‚îÇ   ‚îÇGpuEdgeVM     ‚îÇ    ‚îÇGpuCloudletScheduler‚îÇ   ‚îÇGpuTask   ‚îÇ   ‚îÇGpu  ‚îÇ
‚îÇManager           ‚îÇ   ‚îÇ              ‚îÇ    ‚îÇTimeShared          ‚îÇ   ‚îÇ          ‚îÇ   ‚îÇ     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò
          ‚îÇ                   ‚îÇ                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ submitTask(gpuTask)                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ submitGpuTask(gpuTask)                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ [Adiciona √†        ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ  runningTasks]     ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ          ‚îÇ         ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ redistributeGpuResources()     ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ          ‚îÇ         ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ setGpuStartTime()  ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ  true                ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ  true             ‚îÇ                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ [Tempo passa - SimManager chama updateGpuTaskProcessing()]    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ updateGpuTaskProcessing(currentTime)      ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ [Calcula delta     ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ  de tempo]         ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ          ‚îÇ         ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ getGflops()        ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ  gflops            ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ [Para cada tarefa, ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ  calcula trabalho  ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ  realizado]        ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ          ‚îÇ         ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ [Tarefa completou?]‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ          ‚îÇ         ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ finishGpuTask(gpuTask)         ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ          ‚îÇ         ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ          ‚îÇ setGpuFinishTime()  ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ          ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ          ‚îÇ         ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ          ‚îÇ setActualGpuUtilization()
          ‚îÇ                   ‚îÇ                      ‚îÇ          ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ          ‚îÇ         ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ          ‚îÇ [Move para          ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ          ‚îÇ  completedTasks]    ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ setUtilization()   ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ  nextEventTime       ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ getCompletedGpuTasks()                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ                      ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                    ‚îÇ           ‚îÇ
          ‚îÇ                   ‚îÇ  List<GpuTask>       ‚îÇ                    ‚îÇ           ‚îÇ
```

**Descri√ß√£o:**
1. **MobileDeviceManager** submete **GpuTask** para **GpuEdgeVM**
2. **GpuEdgeVM** delega para **GpuCloudletSchedulerTimeShared**
3. Scheduler adiciona tarefa √† fila **runningTasks**
4. Redistributes GPU resources (time-slicing)
5. Define tempo de in√≠cio da tarefa GPU
6. Durante simula√ß√£o, **updateGpuTaskProcessing()** √© chamado periodicamente
7. Calcula trabalho realizado baseado em:
   - Delta de tempo
   - GFLOPS da GPU
   - N√∫mero de tarefas compartilhando GPU (time-shared)
8. Quando tarefa completa:
   - Define tempo de fim
   - Calcula utiliza√ß√£o real
   - Move para **completedTasks**
9. **MobileDeviceManager** recupera tarefas completadas

---

### 4.4 Fluxo: Desaloca√ß√£o de Recursos

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇSimManager        ‚îÇ   ‚îÇGpuEdgeVmAllocation   ‚îÇ   ‚îÇGpuEdgeHost  ‚îÇ   ‚îÇGpuProvisioner‚îÇ   ‚îÇGpu  ‚îÇ
‚îÇ                  ‚îÇ   ‚îÇPolicy_Custom         ‚îÇ   ‚îÇ             ‚îÇ   ‚îÇ              ‚îÇ   ‚îÇ     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ              ‚îÇ
         ‚îÇ vmDestroy(vm)          ‚îÇ                      ‚îÇ                 ‚îÇ              ‚îÇ
         ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                      ‚îÇ                 ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ deallocateHostForVm(vm)                ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                 ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ [Verifica se VM ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ  tem GPU]       ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ      ‚îÇ          ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ deallocateGpuForVm(vm)         ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ [Encontra GPU‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ  alocada]    ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ      ‚îÇ       ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ reset()      ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ [GPU fields: ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ  allocatedVm=null
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ  utilization=0
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ  usedMemory=0]
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ       ‚îÇ      ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ vmDestroy(vm)   ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ      ‚îÇ          ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                 ‚îÇ              ‚îÇ
         ‚îÇ                        ‚îÇ                      ‚îÇ                 ‚îÇ              ‚îÇ
         ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                      ‚îÇ                 ‚îÇ              ‚îÇ
         ‚îÇ  void                  ‚îÇ                      ‚îÇ                 ‚îÇ              ‚îÇ
```

**Descri√ß√£o:**
1. **SimManager** solicita destrui√ß√£o de VM
2. **GpuEdgeVmAllocationPolicy_Custom** recebe **deallocateHostForVm()**
3. Verifica se a VM possui GPU alocada
4. Se sim, chama **deallocateGpuForVm()** no **GpuEdgeHost**
5. **GpuEdgeHost** delega para **GpuProvisioner**
6. **GpuProvisioner** encontra a GPU alocada para a VM
7. Chama **reset()** na GPU para limpar estado:
   - `allocatedVm = null`
   - `utilization = 0`
   - `usedMemory = 0`
8. Remove mapeamento VM‚ÜíGPU
9. GPU fica dispon√≠vel para novas aloca√ß√µes
10. Host destr√≥i a VM normalmente

---

## 5. Exemplos de Uso

### 5.1 Criando GpuEdgeServerManager Personalizado

```java
package edu.boun.edgecloudsim.applications.gpu_app;

import edu.boun.edgecloudsim.core.ScenarioFactory;
import edu.boun.edgecloudsim.edge_server.EdgeServerManager;
import edu.boun.edgecloudsim.edge_server.GpuEdgeServerManager;

/**
 * Factory personalizada para cen√°rios com suporte a GPU.
 */
public class GpuScenarioFactory implements ScenarioFactory {
    private int numOfMobileDevice;
    private double simulationTime;
    private String orchestratorPolicy;
    private String simScenario;
    
    public GpuScenarioFactory(int _numOfMobileDevice,
                              double _simulationTime,
                              String _orchestratorPolicy,
                              String _simScenario) {
        this.numOfMobileDevice = _numOfMobileDevice;
        this.simulationTime = _simulationTime;
        this.orchestratorPolicy = _orchestratorPolicy;
        this.simScenario = _simScenario;
    }
    
    @Override
    public EdgeServerManager getEdgeServerManager() {
        // Retorna implementa√ß√£o GPU em vez da padr√£o
        return new GpuEdgeServerManager();
    }
    
    // ... outros m√©todos factory
}
```

**Uso:**

```java
public class MainApp {
    public static void main(String[] args) throws Exception {
        // Inicializa CloudSim
        CloudSim.init(numBrokers, calendar, traceFlag);
        
        // Cria factory GPU
        ScenarioFactory factory = new GpuScenarioFactory(
            numMobileDevices,
            simulationTime,
            "GPU_AWARE_ORCHESTRATOR",
            "DEEP_LEARNING_INFERENCE"
        );
        
        // Cria SimManager com factory GPU
        SimManager simManager = new SimManager(factory, numMobileDevices, simScenario);
        
        // Inicia simula√ß√£o
        simManager.startSimulation();
    }
}
```

---

### 5.2 Configurando edge_devices.xml com GPUs

```xml
<?xml version="1.0"?>
<edge_devices>
    <datacenter arch="x86" os="Linux" vmm="Xen">
        <!-- Custos do datacenter -->
        <costPerBw>0.1</costPerBw>
        <costPerSec>3.0</costPerSec>
        <costPerMem>0.05</costPerMem>
        <costPerStorage>0.1</costPerStorage>
        
        <!-- Localiza√ß√£o geogr√°fica -->
        <location>
            <x_pos>1</x_pos>
            <y_pos>1</y_pos>
            <wlan_id>0</wlan_id>
            <attractiveness>5</attractiveness>
        </location>
        
        <hosts>
            <host>
                <!-- Recursos CPU tradicionais -->
                <core>16</core>
                <mips>80000</mips>
                <ram>32000</ram>
                <storage>100000</storage>
                
                <!-- ‚≠ê NOVO: Configura√ß√£o de GPUs -->
                <gpus>
                    <gpu>
                        <gpu_id>0</gpu_id>
                        <gpu_type>NVIDIA_T4</gpu_type>
                        <cuda_cores>2560</cuda_cores>
                        <gflops>8100</gflops>
                        <gpu_memory>16000</gpu_memory>
                        <memory_bandwidth>320</memory_bandwidth>
                    </gpu>
                    <gpu>
                        <gpu_id>1</gpu_id>
                        <gpu_type>NVIDIA_A100</gpu_type>
                        <cuda_cores>6912</cuda_cores>
                        <gflops>19500</gflops>
                        <gpu_memory>40000</gpu_memory>
                        <memory_bandwidth>1555</memory_bandwidth>
                    </gpu>
                </gpus>
                
                <!-- VMs com suporte a GPU -->
                <VMs>
                    <!-- VM com GPU exclusiva -->
                    <VM vmm="Xen">
                        <core>4</core>
                        <mips>20000</mips>
                        <ram>8000</ram>
                        <storage>50000</storage>
                        <!-- ‚≠ê NOVO: Requisitos GPU -->
                        <requires_gpu>true</requires_gpu>
                        <gpu_allocation_mode>EXCLUSIVE</gpu_allocation_mode>
                    </VM>
                    
                    <!-- VM sem GPU -->
                    <VM vmm="Xen">
                        <core>4</core>
                        <mips>20000</mips>
                        <ram>8000</ram>
                        <storage>50000</storage>
                        <requires_gpu>false</requires_gpu>
                    </VM>
                    
                    <!-- VM com GPU compartilhada (futuro) -->
                    <VM vmm="Xen">
                        <core>2</core>
                        <mips>10000</mips>
                        <ram>4000</ram>
                        <storage>25000</storage>
                        <requires_gpu>true</requires_gpu>
                        <gpu_allocation_mode>SHARED</gpu_allocation_mode>
                    </VM>
                </VMs>
            </host>
        </hosts>
    </datacenter>
</edge_devices>
```

---

### 5.3 Configurando applications.xml com Tarefas GPU

```xml
<?xml version="1.0"?>
<applications>
    <!-- Aplica√ß√£o com processamento intensivo em GPU -->
    <application name="DEEP_LEARNING_INFERENCE">
        <usage_percentage>30</usage_percentage>
        <prob_cloud_selection>10</prob_cloud_selection>
        <poisson_interarrival>5</poisson_interarrival>
        <delay_sensitivity>1</delay_sensitivity>
        <active_period>60</active_period>
        <idle_period>30</idle_period>
        
        <!-- Requisitos tradicionais CPU -->
        <data_upload>5000</data_upload>
        <data_download>500</data_download>
        <task_length>50000</task_length>
        <required_core>2</required_core>
        <vm_utilization_on_edge>10</vm_utilization_on_edge>
        <vm_utilization_on_cloud>0.8</vm_utilization_on_cloud>
        <vm_utilization_on_mobile>20</vm_utilization_on_mobile>
        
        <!-- ‚≠ê NOVO: Requisitos GPU -->
        <requires_gpu>true</requires_gpu>
        <gpu_length>150000</gpu_length>              <!-- GFLOPs -->
        <gpu_input_data>2000</gpu_input_data>        <!-- MB -->
        <gpu_output_data>100</gpu_output_data>       <!-- MB -->
        <required_gpu_memory>4000</required_gpu_memory> <!-- MB -->
        <expected_gpu_utilization>80</expected_gpu_utilization> <!-- % -->
    </application>
    
    <!-- Aplica√ß√£o tradicional sem GPU -->
    <application name="WEB_BROWSING">
        <usage_percentage>40</usage_percentage>
        <prob_cloud_selection>30</prob_cloud_selection>
        <poisson_interarrival>10</poisson_interarrival>
        <delay_sensitivity>2</delay_sensitivity>
        <active_period>120</active_period>
        <idle_period>60</idle_period>
        
        <data_upload>1000</data_upload>
        <data_download>500</data_download>
        <task_length>10000</task_length>
        <required_core>1</required_core>
        <vm_utilization_on_edge>5</vm_utilization_on_edge>
        
        <!-- Sem requisitos GPU -->
        <requires_gpu>false</requires_gpu>
    </application>
    
    <!-- Aplica√ß√£o h√≠brida CPU+GPU -->
    <application name="VIDEO_TRANSCODING">
        <usage_percentage>20</usage_percentage>
        <prob_cloud_selection>20</prob_cloud_selection>
        <poisson_interarrival>8</poisson_interarrival>
        <delay_sensitivity>3</delay_sensitivity>
        <active_period>90</active_period>
        <idle_period>45</idle_period>
        
        <!-- Processamento CPU significativo -->
        <data_upload>10000</data_upload>
        <data_download>8000</data_download>
        <task_length>100000</task_length>
        <required_core>4</required_core>
        <vm_utilization_on_edge>15</vm_utilization_on_edge>
        
        <!-- + Processamento GPU moderado -->
        <requires_gpu>true</requires_gpu>
        <gpu_length>80000</gpu_length>
        <gpu_input_data>5000</gpu_input_data>
        <gpu_output_data>5000</gpu_output_data>
        <required_gpu_memory>6000</required_gpu_memory>
        <expected_gpu_utilization>60</expected_gpu_utilization>
    </application>
</applications>
```

---

### 5.4 Criando e Submetendo GpuTask

```java
package edu.boun.edgecloudsim.applications.gpu_app;

import edu.boun.edgecloudsim.edge_client.GpuTask;
import edu.boun.edgecloudsim.edge_client.CpuUtilizationModel_Custom;
import org.cloudbus.cloudsim.UtilizationModelFull;

/**
 * Gerador de tarefas GPU personalizado.
 */
public class GpuLoadGenerator extends LoadGeneratorModel {
    
    @Override
    public void initializeModel() {
        // Inicializa√ß√£o
    }
    
    /**
     * Cria uma GpuTask com requisitos CPU e GPU.
     */
    private GpuTask createGpuTask(int mobileDeviceId, int taskType) {
        // Obter configura√ß√µes da aplica√ß√£o
        int taskId = taskIdCounter++;
        
        // Requisitos CPU (padr√£o EdgeCloudSim)
        long cloudletLength = 50000;      // MI
        int pesNumber = 2;                 // Cores
        long cloudletFileSize = 5000;     // bytes
        long cloudletOutputSize = 500;    // bytes
        
        // Requisitos GPU (novo)
        long gpuLength = 150000;           // GFLOPs
        long gpuInputData = 2000;          // MB
        long gpuOutputData = 100;          // MB
        long requiredGpuMemory = 4000;     // MB
        
        // Modelos de utiliza√ß√£o
        CpuUtilizationModel_Custom cpuModel = 
            new CpuUtilizationModel_Custom(taskType, 
                SimSettings.TYPES.EDGE_DATACENTER);
        UtilizationModelFull ramModel = new UtilizationModelFull();
        UtilizationModelFull bwModel = new UtilizationModelFull();
        
        // Criar GpuTask
        GpuTask gpuTask = new GpuTask(
            mobileDeviceId,
            taskId,
            cloudletLength,
            pesNumber,
            cloudletFileSize,
            cloudletOutputSize,
            cpuModel,
            ramModel,
            bwModel,
            gpuLength,
            gpuInputData,
            gpuOutputData,
            requiredGpuMemory
        );
        
        // Configurar tipo de tarefa
        gpuTask.setTaskType(taskType);
        gpuTask.setExpectedGpuUtilization(80.0);
        
        return gpuTask;
    }
    
    /**
     * Submete tarefa GPU para execu√ß√£o.
     */
    public void submitTask(GpuTask gpuTask) {
        // Orquestrador decide para onde enviar
        int targetDatacenterId = edgeOrchestrator.getDeviceToOffload(gpuTask);
        int targetVmId = edgeOrchestrator.getVmToOffload(gpuTask, targetDatacenterId);
        
        // Define associa√ß√µes
        gpuTask.setAssociatedDatacenterId(targetDatacenterId);
        gpuTask.setAssociatedVmId(targetVmId);
        
        // Envia para o broker
        schedule(
            SimManager.getInstance().getEdgeServerManager().getDatacenterList().get(0).getId(),
            0,
            CREATE_TASK_NOW,
            gpuTask
        );
    }
}
```

---

### 5.5 Processando GpuTask em GpuEdgeVM

```java
package edu.boun.edgecloudsim.edge_client;

import edu.boun.edgecloudsim.core.SimManager;
import edu.boun.edgecloudsim.edge_server.GpuEdgeVM;
import org.cloudbus.cloudsim.core.CloudSim;

/**
 * Gerenciador de dispositivos m√≥veis com suporte a GpuTask.
 */
public class GpuMobileDeviceManager extends MobileDeviceManager {
    
    /**
     * Processa submiss√£o de tarefa (GPU ou tradicional).
     */
    @Override
    public void submitTask(Task task) {
        if (task instanceof GpuTask) {
            submitGpuTask((GpuTask) task);
        } else {
            super.submitTask(task);
        }
    }
    
    /**
     * Submete GpuTask para VM apropriada.
     */
    private void submitGpuTask(GpuTask gpuTask) {
        // Obt√©m VM de destino
        int vmId = gpuTask.getAssociatedVmId();
        int datacenterId = gpuTask.getAssociatedDatacenterId();
        
        GpuEdgeVM vm = (GpuEdgeVM) SimManager.getInstance()
            .getEdgeServerManager()
            .getVmList(datacenterId)
            .get(vmId);
        
        // Verifica se VM tem GPU (se tarefa requer)
        if (gpuTask.requiresGpu() && !vm.hasGpu()) {
            SimLogger.printLine(CloudSim.clock() + 
                ": Task #" + gpuTask.getCloudletId() + 
                " FAILED - VM #" + vmId + " has no GPU");
            gpuTask.setCloudletStatus(Cloudlet.FAILED);
            return;
        }
        
        // Verifica mem√≥ria GPU dispon√≠vel
        if (gpuTask.requiresGpu()) {
            long availableMemory = vm.getAvailableGpuMemory();
            if (availableMemory < gpuTask.getRequiredGpuMemory()) {
                SimLogger.printLine(CloudSim.clock() + 
                    ": Task #" + gpuTask.getCloudletId() + 
                    " FAILED - Insufficient GPU memory");
                gpuTask.setCloudletStatus(Cloudlet.FAILED);
                return;
            }
        }
        
        // Define timestamps
        gpuTask.setSubmittedLocation(
            mobilityModel.getLocation(gpuTask.getMobileDeviceId(), CloudSim.clock())
        );
        gpuTask.setGpuStartTime(CloudSim.clock());
        
        // Submete tarefa GPU
        boolean success = vm.submitGpuTask(gpuTask);
        
        if (success) {
            SimLogger.printLine(CloudSim.clock() + 
                ": GpuTask #" + gpuTask.getCloudletId() + 
                " submitted to VM #" + vmId + 
                " with GPU #" + vm.getGpu().getId());
        } else {
            SimLogger.printLine(CloudSim.clock() + 
                ": GpuTask #" + gpuTask.getCloudletId() + 
                " REJECTED by VM #" + vmId);
            gpuTask.setCloudletStatus(Cloudlet.FAILED);
        }
    }
    
    /**
     * Processa conclus√£o de tarefa GPU.
     */
    private void processGpuTaskCompletion(GpuTask gpuTask) {
        // Calcula m√©tricas finais
        double totalGpuTime = gpuTask.getTotalGpuTime();
        double gpuIntensity = gpuTask.getGpuIntensity();
        
        // Log resultados
        SimLogger.getInstance().addGpuTaskLog(
            CloudSim.clock(),
            gpuTask.getMobileDeviceId(),
            gpuTask.getAssociatedVmId(),
            gpuTask.getExecutedGpuId(),
            gpuTask.getCloudletId(),
            gpuTask.getActualGpuUtilization(),
            gpuTask.getRequiredGpuMemory(),
            gpuTask.getGpuExecutionTime(),
            gpuTask.getGpuDataTransferTime() + gpuTask.getGpuDataBackTime()
        );
        
        SimLogger.printLine(CloudSim.clock() + 
            ": GpuTask #" + gpuTask.getCloudletId() + 
            " COMPLETED - Total GPU Time: " + totalGpuTime + "s, " +
            "GPU Intensity: " + (gpuIntensity * 100) + "%");
    }
}
```

---

### 5.6 Implementando GpuProvisioner Customizado

```java
package edu.boun.edgecloudsim.edge_server;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Provisioner GPU com estrat√©gia Best-Fit baseada em capacidade.
 */
public class GpuProvisionerBestFit implements GpuProvisioner {
    private List<Gpu> gpuList;
    private Map<Integer, Gpu> vmGpuMap;
    
    public GpuProvisionerBestFit(List<Gpu> gpuList) {
        this.gpuList = gpuList;
        this.vmGpuMap = new HashMap<>();
        
        // Associa GPUs ao host
        for (Gpu gpu : gpuList) {
            // Assuming host is set elsewhere or passed as parameter
        }
    }
    
    @Override
    public boolean allocateGpuForVm(GpuEdgeVM vm, Gpu gpu) {
        if (gpu == null || !gpu.isAvailable()) {
            return false;
        }
        
        // Aloca GPU para VM
        gpu.setAllocatedVm(vm);
        vmGpuMap.put(vm.getId(), gpu);
        
        return true;
    }
    
    @Override
    public void deallocateGpuForVm(GpuEdgeVM vm) {
        Gpu gpu = vmGpuMap.remove(vm.getId());
        if (gpu != null) {
            gpu.reset();
        }
    }
    
    @Override
    public boolean hasAvailableGpu() {
        return gpuList.stream().anyMatch(Gpu::isAvailable);
    }
    
    @Override
    public Gpu getAvailableGpu() {
        // Best-Fit: retorna GPU dispon√≠vel com maior capacidade
        return gpuList.stream()
            .filter(Gpu::isAvailable)
            .max(Comparator.comparingDouble(Gpu::getGflops))
            .orElse(null);
    }
    
    @Override
    public Gpu getAvailableGpuWithMemory(long requiredMemory) {
        // Best-Fit com mem√≥ria: GPU com menor mem√≥ria suficiente
        return gpuList.stream()
            .filter(Gpu::isAvailable)
            .filter(gpu -> gpu.getGpuMemory() >= requiredMemory)
            .min(Comparator.comparingLong(Gpu::getGpuMemory))
            .orElse(null);
    }
    
    @Override
    public List<Gpu> getGpuList() {
        return Collections.unmodifiableList(gpuList);
    }
    
    @Override
    public List<Gpu> getAvailableGpuList() {
        return gpuList.stream()
            .filter(Gpu::isAvailable)
            .collect(Collectors.toList());
    }
    
    @Override
    public List<Gpu> getAllocatedGpuList() {
        return gpuList.stream()
            .filter(gpu -> !gpu.isAvailable())
            .collect(Collectors.toList());
    }
    
    /**
     * Estrat√©gia alternativa: Least-Loaded
     * Retorna GPU com menor utiliza√ß√£o atual.
     */
    public Gpu getAvailableGpuLeastLoaded() {
        return gpuList.stream()
            .filter(Gpu::isAvailable)
            .min(Comparator.comparingDouble(Gpu::getUtilization))
            .orElse(null);
    }
}
```

---

### 5.7 Logging de M√©tricas GPU

```java
package edu.boun.edgecloudsim.utils;

import java.io.*;
import java.util.*;

/**
 * Extens√£o do SimLogger para m√©tricas GPU.
 */
public class GpuSimLogger extends SimLogger {
    
    private List<GpuTaskLogItem> gpuTaskLog;
    private List<GpuUtilizationLogItem> gpuUtilizationLog;
    
    private BufferedWriter gpuTaskLogWriter;
    private BufferedWriter gpuUtilizationLogWriter;
    
    public GpuSimLogger(String outputFolder) {
        super(outputFolder);
        gpuTaskLog = new ArrayList<>();
        gpuUtilizationLog = new ArrayList<>();
    }
    
    /**
     * Adiciona log de tarefa GPU.
     */
    public void addGpuTaskLog(double time, int mobileDeviceId, int vmId,
                               int gpuId, int taskId, double gpuUtilization,
                               long gpuMemoryUsed, double gpuExecutionTime,
                               double gpuDataTransferTime) {
        GpuTaskLogItem item = new GpuTaskLogItem(
            time, mobileDeviceId, vmId, gpuId, taskId,
            gpuUtilization, gpuMemoryUsed, gpuExecutionTime, gpuDataTransferTime
        );
        gpuTaskLog.add(item);
    }
    
    /**
     * Adiciona log de utiliza√ß√£o GPU.
     */
    public void addGpuUtilizationLog(double time, int hostId, int gpuId,
                                      double utilization, long usedMemory,
                                      int allocatedVmId) {
        GpuUtilizationLogItem item = new GpuUtilizationLogItem(
            time, hostId, gpuId, utilization, usedMemory, allocatedVmId
        );
        gpuUtilizationLog.add(item);
    }
    
    /**
     * Escreve logs GPU em arquivos CSV.
     */
    @Override
    public void simStopped() {
        super.simStopped();
        
        try {
            // GPU Task Log
            gpuTaskLogWriter = new BufferedWriter(new FileWriter(
                outputFolder + "/gpu_task_log.csv"));
            gpuTaskLogWriter.write(
                "Time,MobileDeviceId,VmId,GpuId,TaskId," +
                "GpuUtilization,GpuMemoryUsed,GpuExecutionTime,GpuDataTransferTime\n");
            
            for (GpuTaskLogItem item : gpuTaskLog) {
                gpuTaskLogWriter.write(item.toString() + "\n");
            }
            gpuTaskLogWriter.close();
            
            // GPU Utilization Log
            gpuUtilizationLogWriter = new BufferedWriter(new FileWriter(
                outputFolder + "/gpu_utilization_log.csv"));
            gpuUtilizationLogWriter.write(
                "Time,HostId,GpuId,Utilization,UsedMemory,AllocatedVmId\n");
            
            for (GpuUtilizationLogItem item : gpuUtilizationLog) {
                gpuUtilizationLogWriter.write(item.toString() + "\n");
            }
            gpuUtilizationLogWriter.close();
            
            SimLogger.printLine("GPU logs escritos com sucesso!");
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    /**
     * Classe interna para log de tarefa GPU.
     */
    private static class GpuTaskLogItem {
        double time;
        int mobileDeviceId, vmId, gpuId, taskId;
        double gpuUtilization, gpuExecutionTime, gpuDataTransferTime;
        long gpuMemoryUsed;
        
        public GpuTaskLogItem(double time, int mobileDeviceId, int vmId,
                               int gpuId, int taskId, double gpuUtilization,
                               long gpuMemoryUsed, double gpuExecutionTime,
                               double gpuDataTransferTime) {
            this.time = time;
            this.mobileDeviceId = mobileDeviceId;
            this.vmId = vmId;
            this.gpuId = gpuId;
            this.taskId = taskId;
            this.gpuUtilization = gpuUtilization;
            this.gpuMemoryUsed = gpuMemoryUsed;
            this.gpuExecutionTime = gpuExecutionTime;
            this.gpuDataTransferTime = gpuDataTransferTime;
        }
        
        @Override
        public String toString() {
            return String.format("%.2f,%d,%d,%d,%d,%.2f,%d,%.4f,%.4f",
                time, mobileDeviceId, vmId, gpuId, taskId,
                gpuUtilization, gpuMemoryUsed, gpuExecutionTime, gpuDataTransferTime);
        }
    }
    
    /**
     * Classe interna para log de utiliza√ß√£o GPU.
     */
    private static class GpuUtilizationLogItem {
        double time;
        int hostId, gpuId, allocatedVmId;
        double utilization;
        long usedMemory;
        
        public GpuUtilizationLogItem(double time, int hostId, int gpuId,
                                      double utilization, long usedMemory,
                                      int allocatedVmId) {
            this.time = time;
            this.hostId = hostId;
            this.gpuId = gpuId;
            this.utilization = utilization;
            this.usedMemory = usedMemory;
            this.allocatedVmId = allocatedVmId;
        }
        
        @Override
        public String toString() {
            return String.format("%.2f,%d,%d,%.2f,%d,%d",
                time, hostId, gpuId, utilization, usedMemory, allocatedVmId);
        }
    }
}
```

---

## 6. Estrat√©gias de Teste

### 6.1 Plano Geral de Testes

**N√≠veis de Teste:**

| N√≠vel | Descri√ß√£o | Ferramentas |
|-------|-----------|-------------|
| **Unit Tests** | Teste de classes individuais isoladas | JUnit 5, Mockito |
| **Integration Tests** | Teste de intera√ß√£o entre classes GPU | JUnit 5, TestContainers |
| **System Tests** | Teste de cen√°rios completos de simula√ß√£o | JUnit 5, assertj |
| **Performance Tests** | Teste de escalabilidade e desempenho | JMH, VisualVM |
| **Validation Tests** | Compara√ß√£o com resultados esperados | Custom scripts |

**Cobertura de C√≥digo Alvo:** ‚â• 80% para classes cr√≠ticas

---

### 6.2 Testes Unit√°rios

#### 6.2.1 Teste: Classe Gpu

```java
package edu.boun.edgecloudsim.edge_server;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Testes unit√°rios para a classe Gpu.
 */
class GpuTest {
    
    private Gpu gpu;
    
    @BeforeEach
    void setUp() {
        gpu = new Gpu(0, "NVIDIA_T4", 2560, 8100.0, 16000, 320.0);
    }
    
    @Test
    @DisplayName("Construtor deve inicializar atributos corretamente")
    void testConstructor() {
        assertEquals(0, gpu.getId());
        assertEquals("NVIDIA_T4", gpu.getGpuType());
        assertEquals(2560, gpu.getCudaCores());
        assertEquals(8100.0, gpu.getGflops(), 0.01);
        assertEquals(16000, gpu.getGpuMemory());
        assertEquals(320.0, gpu.getMemoryBandwidth(), 0.01);
        assertEquals(0.0, gpu.getUtilization(), 0.01);
        assertTrue(gpu.isAvailable());
    }
    
    @Test
    @DisplayName("isAvailable() deve retornar true quando GPU n√£o alocada")
    void testIsAvailableWhenNotAllocated() {
        assertTrue(gpu.isAvailable());
    }
    
    @Test
    @DisplayName("isAvailable() deve retornar false quando GPU alocada")
    void testIsAvailableWhenAllocated() {
        GpuEdgeVM mockVm = new GpuEdgeVM(1, 1, 1000, 2, 2000, 1000, 10000, 
            "Xen", null, null, true);
        gpu.setAllocatedVm(mockVm);
        
        assertFalse(gpu.isAvailable());
    }
    
    @Test
    @DisplayName("allocateMemory() deve retornar true quando h√° mem√≥ria suficiente")
    void testAllocateMemorySuccess() {
        assertTrue(gpu.allocateMemory(8000));
        assertEquals(8000, gpu.getUsedMemory());
        assertEquals(8000, gpu.getAvailableMemory());
    }
    
    @Test
    @DisplayName("allocateMemory() deve retornar false quando mem√≥ria insuficiente")
    void testAllocateMemoryFailure() {
        gpu.allocateMemory(10000);
        assertFalse(gpu.allocateMemory(8000)); // Total = 18000 > 16000
        assertEquals(10000, gpu.getUsedMemory());
    }
    
    @Test
    @DisplayName("deallocateMemory() deve liberar mem√≥ria corretamente")
    void testDeallocateMemory() {
        gpu.allocateMemory(8000);
        assertTrue(gpu.deallocateMemory(3000));
        assertEquals(5000, gpu.getUsedMemory());
        assertEquals(11000, gpu.getAvailableMemory());
    }
    
    @Test
    @DisplayName("calculateExecutionTime() deve calcular tempo corretamente")
    void testCalculateExecutionTime() {
        long gpuLength = 8100; // GFLOPs
        double expectedTime = (gpuLength * 1000000.0) / gpu.getGflops(); // segundos
        
        double actualTime = gpu.calculateExecutionTime(gpuLength);
        
        assertEquals(expectedTime, actualTime, 0.01);
    }
    
    @Test
    @DisplayName("calculateDataTransferTime() deve calcular tempo de transfer√™ncia")
    void testCalculateDataTransferTime() {
        long dataSize = 1000; // MB
        double expectedTime = (dataSize * 8.0) / gpu.getMemoryBandwidth(); // segundos
        
        double actualTime = gpu.calculateDataTransferTime(dataSize);
        
        assertEquals(expectedTime, actualTime, 0.01);
    }
    
    @Test
    @DisplayName("reset() deve resetar GPU para estado inicial")
    void testReset() {
        GpuEdgeVM mockVm = new GpuEdgeVM(1, 1, 1000, 2, 2000, 1000, 10000, 
            "Xen", null, null, true);
        gpu.setAllocatedVm(mockVm);
        gpu.setUtilization(75.0);
        gpu.allocateMemory(5000);
        
        gpu.reset();
        
        assertNull(gpu.getAllocatedVm());
        assertEquals(0.0, gpu.getUtilization(), 0.01);
        assertEquals(0, gpu.getUsedMemory());
        assertTrue(gpu.isAvailable());
    }
}
```

#### 6.2.2 Teste: GpuProvisionerSimple

```java
package edu.boun.edgecloudsim.edge_server;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;
import java.util.*;

/**
 * Testes unit√°rios para GpuProvisionerSimple.
 */
class GpuProvisionerSimpleTest {
    
    private GpuProvisionerSimple provisioner;
    private List<Gpu> gpuList;
    private GpuEdgeVM vm1, vm2;
    
    @BeforeEach
    void setUp() {
        // Criar lista de GPUs
        gpuList = new ArrayList<>();
        gpuList.add(new Gpu(0, "NVIDIA_T4", 2560, 8100.0, 16000, 320.0));
        gpuList.add(new Gpu(1, "NVIDIA_A100", 6912, 19500.0, 40000, 1555.0));
        gpuList.add(new Gpu(2, "NVIDIA_V100", 5120, 15700.0, 32000, 900.0));
        
        provisioner = new GpuProvisionerSimple(gpuList);
        
        // Criar VMs
        vm1 = new GpuEdgeVM(1, 1, 1000, 2, 2000, 1000, 10000, 
            "Xen", null, null, true);
        vm2 = new GpuEdgeVM(2, 1, 1000, 2, 2000, 1000, 10000, 
            "Xen", null, null, true);
    }
    
    @Test
    @DisplayName("hasAvailableGpu() deve retornar true inicialmente")
    void testHasAvailableGpuInitially() {
        assertTrue(provisioner.hasAvailableGpu());
    }
    
    @Test
    @DisplayName("getAvailableGpu() deve retornar primeira GPU dispon√≠vel")
    void testGetAvailableGpu() {
        Gpu gpu = provisioner.getAvailableGpu();
        
        assertNotNull(gpu);
        assertEquals(0, gpu.getId());
        assertTrue(gpu.isAvailable());
    }
    
    @Test
    @DisplayName("allocateGpuForVm() deve alocar GPU com sucesso")
    void testAllocateGpuForVmSuccess() {
        Gpu gpu = provisioner.getAvailableGpu();
        assertTrue(provisioner.allocateGpuForVm(vm1, gpu));
        
        assertFalse(gpu.isAvailable());
        assertEquals(vm1, gpu.getAllocatedVm());
    }
    
    @Test
    @DisplayName("allocateGpuForVm() deve falhar se GPU j√° alocada")
    void testAllocateGpuForVmFailureAlreadyAllocated() {
        Gpu gpu = provisioner.getAvailableGpu();
        provisioner.allocateGpuForVm(vm1, gpu);
        
        assertFalse(provisioner.allocateGpuForVm(vm2, gpu));
    }
    
    @Test
    @DisplayName("deallocateGpuForVm() deve liberar GPU")
    void testDeallocateGpuForVm() {
        Gpu gpu = provisioner.getAvailableGpu();
        provisioner.allocateGpuForVm(vm1, gpu);
        
        provisioner.deallocateGpuForVm(vm1);
        
        assertTrue(gpu.isAvailable());
        assertNull(gpu.getAllocatedVm());
    }
    
    @Test
    @DisplayName("getAvailableGpuWithMemory() deve retornar GPU com mem√≥ria suficiente")
    void testGetAvailableGpuWithMemory() {
        long requiredMemory = 20000; // MB
        Gpu gpu = provisioner.getAvailableGpuWithMemory(requiredMemory);
        
        assertNotNull(gpu);
        assertTrue(gpu.getGpuMemory() >= requiredMemory);
        assertEquals(1, gpu.getId()); // NVIDIA_A100 com 40GB
    }
    
    @Test
    @DisplayName("getAvailableGpuWithMemory() deve retornar null se sem mem√≥ria suficiente")
    void testGetAvailableGpuWithMemoryFailure() {
        long requiredMemory = 50000; // MB (mais que qualquer GPU)
        Gpu gpu = provisioner.getAvailableGpuWithMemory(requiredMemory);
        
        assertNull(gpu);
    }
    
    @Test
    @DisplayName("getAvailableGpuList() deve retornar apenas GPUs dispon√≠veis")
    void testGetAvailableGpuList() {
        Gpu gpu1 = gpuList.get(0);
        provisioner.allocateGpuForVm(vm1, gpu1);
        
        List<Gpu> availableGpus = provisioner.getAvailableGpuList();
        
        assertEquals(2, availableGpus.size());
        assertFalse(availableGpus.contains(gpu1));
    }
    
    @Test
    @DisplayName("getAllocatedGpuList() deve retornar apenas GPUs alocadas")
    void testGetAllocatedGpuList() {
        Gpu gpu1 = gpuList.get(0);
        provisioner.allocateGpuForVm(vm1, gpu1);
        
        List<Gpu> allocatedGpus = provisioner.getAllocatedGpuList();
        
        assertEquals(1, allocatedGpus.size());
        assertTrue(allocatedGpus.contains(gpu1));
    }
    
    @Test
    @DisplayName("getAverageUtilization() deve calcular utiliza√ß√£o m√©dia")
    void testGetAverageUtilization() {
        gpuList.get(0).setUtilization(50.0);
        gpuList.get(1).setUtilization(75.0);
        gpuList.get(2).setUtilization(25.0);
        
        double avgUtilization = provisioner.getAverageUtilization();
        
        assertEquals(50.0, avgUtilization, 0.01);
    }
}
```

#### 6.2.3 Teste: GpuTask

```java
package edu.boun.edgecloudsim.edge_client;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Testes unit√°rios para GpuTask.
 */
class GpuTaskTest {
    
    private GpuTask gpuTask;
    
    @BeforeEach
    void setUp() {
        gpuTask = new GpuTask(
            1,      // cloudletId
            0,      // taskId
            50000,  // cloudletLength (MI)
            2,      // pesNumber
            5000,   // cloudletFileSize
            500,    // cloudletOutputSize
            150000, // gpuLength (GFLOPs)
            2000,   // gpuInputData (MB)
            100,    // gpuOutputData (MB)
            4000    // requiredGpuMemory (MB)
        );
    }
    
    @Test
    @DisplayName("Construtor deve inicializar atributos GPU corretamente")
    void testConstructor() {
        assertEquals(150000, gpuTask.getGpuLength());
        assertEquals(2000, gpuTask.getGpuInputData());
        assertEquals(100, gpuTask.getGpuOutputData());
        assertEquals(4000, gpuTask.getRequiredGpuMemory());
        assertEquals(-1, gpuTask.getExecutedGpuId());
        assertEquals(0.0, gpuTask.getGpuExecutionTime(), 0.01);
    }
    
    @Test
    @DisplayName("requiresGpu() deve retornar true quando gpuLength > 0")
    void testRequiresGpu() {
        assertTrue(gpuTask.requiresGpu());
    }
    
    @Test
    @DisplayName("requiresGpu() deve retornar false quando gpuLength = 0")
    void testDoesNotRequireGpu() {
        GpuTask taskWithoutGpu = new GpuTask(
            2, 0, 50000, 2, 5000, 500,
            0, 0, 0, 0  // Sem requisitos GPU
        );
        
        assertFalse(taskWithoutGpu.requiresGpu());
    }
    
    @Test
    @DisplayName("getTotalGpuTime() deve somar todos os tempos GPU")
    void testGetTotalGpuTime() {
        gpuTask.setGpuDataTransferTime(0.5);
        gpuTask.setGpuExecutionTime(2.0);
        gpuTask.setGpuDataBackTime(0.3);
        
        assertEquals(2.8, gpuTask.getTotalGpuTime(), 0.01);
    }
    
    @Test
    @DisplayName("getGpuIntensity() deve calcular propor√ß√£o GPU/(CPU+GPU)")
    void testGetGpuIntensity() {
        gpuTask.setGpuExecutionTime(2.0);
        // Assuming CPU execution time is calculated based on cloudletLength
        // For simplicity, assume CPU time = 1.0
        // gpuIntensity = 2.0 / (1.0 + 2.0) = 0.666...
        
        // This requires actual calculation logic in GpuTask
        // For now, we'll test the setter/getter
        double expectedIntensity = 0.67;
        // Assuming GpuTask calculates this internally
        
        // Placeholder assertion
        assertTrue(gpuTask.getGpuIntensity() >= 0.0 && gpuTask.getGpuIntensity() <= 1.0);
    }
    
    @Test
    @DisplayName("hasEnoughGpuMemory() deve retornar true quando mem√≥ria suficiente")
    void testHasEnoughGpuMemoryTrue() {
        assertTrue(gpuTask.hasEnoughGpuMemory(5000));
    }
    
    @Test
    @DisplayName("hasEnoughGpuMemory() deve retornar false quando mem√≥ria insuficiente")
    void testHasEnoughGpuMemoryFalse() {
        assertFalse(gpuTask.hasEnoughGpuMemory(3000));
    }
    
    @Test
    @DisplayName("Setters GPU devem funcionar corretamente")
    void testGpuSetters() {
        gpuTask.setExecutedGpuId(2);
        gpuTask.setGpuDataTransferTime(0.75);
        gpuTask.setGpuExecutionTime(3.5);
        gpuTask.setGpuDataBackTime(0.25);
        gpuTask.setActualGpuUtilization(85.0);
        gpuTask.setGpuStartTime(10.0);
        gpuTask.setGpuFinishTime(14.5);
        
        assertEquals(2, gpuTask.getExecutedGpuId());
        assertEquals(0.75, gpuTask.getGpuDataTransferTime(), 0.01);
        assertEquals(3.5, gpuTask.getGpuExecutionTime(), 0.01);
        assertEquals(0.25, gpuTask.getGpuDataBackTime(), 0.01);
        assertEquals(85.0, gpuTask.getActualGpuUtilization(), 0.01);
        assertEquals(10.0, gpuTask.getGpuStartTime(), 0.01);
        assertEquals(14.5, gpuTask.getGpuFinishTime(), 0.01);
    }
}
```

---

### 6.3 Testes de Integra√ß√£o

#### 6.3.1 Teste: GpuEdgeHost com GpuProvisioner

```java
package edu.boun.edgecloudsim.edge_server;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;
import org.cloudbus.cloudsim.Pe;
import org.cloudbus.cloudsim.VmSchedulerSpaceShared;
import org.cloudbus.cloudsim.provisioners.*;
import java.util.*;

/**
 * Testes de integra√ß√£o entre GpuEdgeHost e GpuProvisioner.
 */
class GpuEdgeHostIntegrationTest {
    
    private GpuEdgeHost host;
    private GpuProvisioner provisioner;
    private List<Gpu> gpuList;
    private List<Pe> peList;
    
    @BeforeEach
    void setUp() {
        // Criar PEs (CPU cores)
        peList = new ArrayList<>();
        for (int i = 0; i < 4; i++) {
            peList.add(new Pe(i, new PeProvisionerSimple(10000)));
        }
        
        // Criar GPUs
        gpuList = new ArrayList<>();
        gpuList.add(new Gpu(0, "NVIDIA_T4", 2560, 8100.0, 16000, 320.0));
        gpuList.add(new Gpu(1, "NVIDIA_A100", 6912, 19500.0, 40000, 1555.0));
        
        // Criar GpuProvisioner
        provisioner = new GpuProvisionerSimple(gpuList);
        
        // Criar GpuEdgeHost
        host = new GpuEdgeHost(
            0,
            new RamProvisionerSimple(16000),
            new BwProvisionerSimple(10000),
            100000,
            peList,
            new VmSchedulerSpaceShared(peList),
            gpuList,
            provisioner
        );
        
        // Associar GPUs ao host
        for (Gpu gpu : gpuList) {
            gpu.setHost(host);
        }
    }
    
    @Test
    @DisplayName("Host deve ser criado com GPUs corretas")
    void testHostCreation() {
        assertEquals(2, host.getNumberOfGpus());
        assertNotNull(host.getGpuProvisioner());
        assertTrue(host.hasAvailableGpu());
    }
    
    @Test
    @DisplayName("Host deve alocar GPU para VM corretamente")
    void testAllocateGpuForVm() {
        GpuEdgeVM vm = new GpuEdgeVM(
            1, 1, 10000, 2, 4000, 1000, 10000,
            "Xen", null, null, true
        );
        
        Gpu gpu = host.getAvailableGpu();
        boolean allocated = host.allocateGpuForVm(vm, gpu);
        
        assertTrue(allocated);
        assertFalse(gpu.isAvailable());
        assertEquals(vm, gpu.getAllocatedVm());
    }
    
    @Test
    @DisplayName("Host deve desalocar GPU de VM corretamente")
    void testDeallocateGpuForVm() {
        GpuEdgeVM vm = new GpuEdgeVM(
            1, 1, 10000, 2, 4000, 1000, 10000,
            "Xen", null, null, true
        );
        
        Gpu gpu = host.getAvailableGpu();
        host.allocateGpuForVm(vm, gpu);
        
        host.deallocateGpuForVm(vm);
        
        assertTrue(gpu.isAvailable());
        assertNull(gpu.getAllocatedVm());
    }
    
    @Test
    @DisplayName("Host deve calcular utiliza√ß√£o m√©dia GPU corretamente")
    void testGetAvgGpuUtilization() {
        gpuList.get(0).setUtilization(60.0);
        gpuList.get(1).setUtilization(80.0);
        
        assertEquals(70.0, host.getAvgGpuUtilization(), 0.01);
    }
    
    @Test
    @DisplayName("Host deve retornar mem√≥ria GPU total correta")
    void testGetTotalGpuMemory() {
        long expectedMemory = 16000 + 40000; // T4 + A100
        assertEquals(expectedMemory, host.getTotalGpuMemory());
    }
    
    @Test
    @DisplayName("Host deve retornar mem√≥ria GPU dispon√≠vel correta")
    void testGetAvailableGpuMemory() {
        gpuList.get(0).allocateMemory(5000);
        gpuList.get(1).allocateMemory(10000);
        
        long expectedAvailable = (16000 - 5000) + (40000 - 10000);
        assertEquals(expectedAvailable, host.getAvailableGpuMemory());
    }
    
    @Test
    @DisplayName("vmCreate() deve alocar GPU automaticamente se VM requer")
    void testVmCreateWithGpu() {
        GpuEdgeVM vm = new GpuEdgeVM(
            1, 1, 10000, 2, 4000, 1000, 10000,
            "Xen", null, null, true
        );
        
        boolean created = host.vmCreate(vm);
        
        assertTrue(created);
        assertTrue(vm.hasGpu());
        assertNotNull(vm.getGpu());
        assertFalse(vm.getGpu().isAvailable());
    }
    
    @Test
    @DisplayName("vmDestroy() deve desalocar GPU automaticamente")
    void testVmDestroyWithGpu() {
        GpuEdgeVM vm = new GpuEdgeVM(
            1, 1, 10000, 2, 4000, 1000, 10000,
            "Xen", null, null, true
        );
        
        host.vmCreate(vm);
        Gpu allocatedGpu = vm.getGpu();
        
        host.vmDestroy(vm);
        
        assertTrue(allocatedGpu.isAvailable());
        assertNull(allocatedGpu.getAllocatedVm());
    }
}
```

#### 6.3.2 Teste: GpuEdgeVM com GpuCloudletScheduler

```java
package edu.boun.edgecloudsim.edge_server;

import edu.boun.edgecloudsim.edge_client.GpuTask;
import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;
import org.cloudbus.cloudsim.CloudletSchedulerTimeShared;

/**
 * Testes de integra√ß√£o entre GpuEdgeVM e GpuCloudletScheduler.
 */
class GpuEdgeVMIntegrationTest {
    
    private GpuEdgeVM vm;
    private Gpu gpu;
    private GpuCloudletSchedulerTimeShared scheduler;
    
    @BeforeEach
    void setUp() {
        gpu = new Gpu(0, "NVIDIA_T4", 2560, 8100.0, 16000, 320.0);
        scheduler = new GpuCloudletSchedulerTimeShared(gpu);
        
        vm = new GpuEdgeVM(
            1, 1, 10000, 2, 4000, 1000, 10000,
            "Xen",
            new CloudletSchedulerTimeShared(),
            scheduler,
            true
        );
        
        vm.setGpu(gpu);
        gpu.setAllocatedVm(vm);
    }
    
    @Test
    @DisplayName("VM deve ser criada com GPU e scheduler corretos")
    void testVmCreation() {
        assertTrue(vm.hasGpu());
        assertEquals(gpu, vm.getGpu());
        assertNotNull(vm.getGpuCloudletScheduler());
        assertTrue(vm.requiresGpu());
    }
    
    @Test
    @DisplayName("submitGpuTask() deve submeter tarefa com sucesso")
    void testSubmitGpuTask() {
        GpuTask task = new GpuTask(
            1, 0, 50000, 2, 5000, 500,
            150000, 2000, 100, 4000
        );
        
        boolean submitted = vm.submitGpuTask(task);
        
        assertTrue(submitted);
        assertEquals(1, vm.getNumberOfRunningGpuTasks());
    }
    
    @Test
    @DisplayName("submitGpuTask() deve aceitar m√∫ltiplas tarefas (time-shared)")
    void testSubmitMultipleGpuTasks() {
        GpuTask task1 = new GpuTask(1, 0, 50000, 2, 5000, 500, 150000, 2000, 100, 4000);
        GpuTask task2 = new GpuTask(2, 0, 50000, 2, 5000, 500, 150000, 2000, 100, 4000);
        GpuTask task3 = new GpuTask(3, 0, 50000, 2, 5000, 500, 150000, 2000, 100, 4000);
        
        vm.submitGpuTask(task1);
        vm.submitGpuTask(task2);
        vm.submitGpuTask(task3);
        
        assertEquals(3, vm.getNumberOfRunningGpuTasks());
    }
    
    @Test
    @DisplayName("getGpuUtilization() deve refletir tarefas em execu√ß√£o")
    void testGetGpuUtilization() {
        GpuTask task = new GpuTask(1, 0, 50000, 2, 5000, 500, 150000, 2000, 100, 4000);
        vm.submitGpuTask(task);
        
        double utilization = vm.getGpuUtilization();
        
        assertTrue(utilization > 0.0);
        assertTrue(utilization <= 100.0);
    }
    
    @Test
    @DisplayName("getAvailableGpuMemory() deve retornar mem√≥ria correta")
    void testGetAvailableGpuMemory() {
        gpu.allocateMemory(5000);
        
        assertEquals(11000, vm.getAvailableGpuMemory());
    }
    
    @Test
    @DisplayName("getCombinedUtilization() deve calcular m√©dia CPU+GPU")
    void testGetCombinedUtilization() {
        // Simular utiliza√ß√£o CPU = 50%
        // Simular utiliza√ß√£o GPU = 70%
        gpu.setUtilization(70.0);
        
        // Expected combined = (50 + 70) / 2 = 60
        // Note: Actual CPU utilization calculation depends on implementation
        
        double combined = vm.getCombinedUtilization();
        assertTrue(combined >= 0.0 && combined <= 100.0);
    }
}
```

---

### 6.4 Testes de Sistema

#### 6.4.1 Teste: Cen√°rio Completo de Simula√ß√£o GPU

```java
package edu.boun.edgecloudsim.integration;

import edu.boun.edgecloudsim.core.*;
import edu.boun.edgecloudsim.applications.gpu_app.GpuScenarioFactory;
import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;
import org.cloudbus.cloudsim.core.CloudSim;

/**
 * Teste de sistema completo para cen√°rio GPU.
 */
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class GpuSimulationSystemTest {
    
    private SimManager simManager;
    
    @BeforeAll
    void setUpSimulation() throws Exception {
        // Configurar CloudSim
        int numBrokers = 1;
        boolean traceFlag = false;
        CloudSim.init(numBrokers, Calendar.getInstance(), traceFlag);
        
        // Configurar SimSettings
        SimSettings.getInstance().initialize(
            "scripts/gpu_app/config/default_config.properties",
            "scripts/gpu_app/config/edge_devices.xml",
            "scripts/gpu_app/config/applications.xml"
        );
        
        // Criar factory GPU
        ScenarioFactory factory = new GpuScenarioFactory(
            200,  // numMobileDevices
            300,  // simulationTime
            "GPU_AWARE",
            "DEEP_LEARNING"
        );
        
        // Criar SimManager
        simManager = new SimManager(factory, 200, "DEEP_LEARNING");
    }
    
    @Test
    @DisplayName("Simula√ß√£o deve iniciar sem erros")
    void testSimulationStart() {
        assertDoesNotThrow(() -> {
            simManager.startSimulation();
        });
    }
    
    @Test
    @DisplayName("Infraestrutura GPU deve ser criada corretamente")
    void testGpuInfrastructureCreation() {
        EdgeServerManager esm = SimManager.getInstance().getEdgeServerManager();
        
        assertTrue(esm instanceof GpuEdgeServerManager);
        assertNotNull(esm.getDatacenterList());
        assertFalse(esm.getDatacenterList().isEmpty());
        
        // Verificar hosts com GPUs
        for (Datacenter dc : esm.getDatacenterList()) {
            for (Host host : dc.getHostList()) {
                if (host instanceof GpuEdgeHost) {
                    GpuEdgeHost gpuHost = (GpuEdgeHost) host;
                    assertTrue(gpuHost.getNumberOfGpus() > 0);
                }
            }
        }
    }
    
    @Test
    @DisplayName("VMs GPU devem ser alocadas corretamente")
    void testGpuVmAllocation() {
        EdgeServerManager esm = SimManager.getInstance().getEdgeServerManager();
        
        int totalVms = 0;
        int gpuVms = 0;
        
        for (int hostId = 0; hostId < esm.getVmList(0).size(); hostId++) {
            List<EdgeVM> vms = esm.getVmList(hostId);
            totalVms += vms.size();
            
            for (EdgeVM vm : vms) {
                if (vm instanceof GpuEdgeVM) {
                    GpuEdgeVM gpuVm = (GpuEdgeVM) vm;
                    if (gpuVm.requiresGpu()) {
                        assertTrue(gpuVm.hasGpu());
                        gpuVms++;
                    }
                }
            }
        }
        
        assertTrue(totalVms > 0);
        assertTrue(gpuVms > 0);
        System.out.println("Total VMs: " + totalVms + ", GPU VMs: " + gpuVms);
    }
    
    @Test
    @DisplayName("Tarefas GPU devem ser executadas e completadas")
    void testGpuTaskExecution() throws Exception {
        // Executar simula√ß√£o curta
        simManager.startSimulation();
        
        // Analisar logs de tarefas GPU
        File gpuTaskLog = new File("sim_results/gpu_task_log.csv");
        assertTrue(gpuTaskLog.exists());
        
        // Ler e validar logs
        List<String> lines = Files.readAllLines(gpuTaskLog.toPath());
        assertTrue(lines.size() > 1); // Header + pelo menos 1 tarefa
        
        // Verificar formato do log
        String[] header = lines.get(0).split(",");
        assertEquals(9, header.length);
        assertEquals("Time", header[0]);
        assertEquals("GpuId", header[3]);
        assertEquals("GpuExecutionTime", header[7]);
    }
    
    @Test
    @DisplayName("M√©tricas de utiliza√ß√£o GPU devem ser coletadas")
    void testGpuUtilizationMetrics() throws Exception {
        simManager.startSimulation();
        
        // Analisar logs de utiliza√ß√£o GPU
        File gpuUtilizationLog = new File("sim_results/gpu_utilization_log.csv");
        assertTrue(gpuUtilizationLog.exists());
        
        List<String> lines = Files.readAllLines(gpuUtilizationLog.toPath());
        assertTrue(lines.size() > 1);
        
        // Verificar se h√° entradas com utiliza√ß√£o > 0
        boolean hasUtilization = lines.stream()
            .skip(1)
            .anyMatch(line -> {
                String[] parts = line.split(",");
                double utilization = Double.parseDouble(parts[3]);
                return utilization > 0.0;
            });
        
        assertTrue(hasUtilization, "Nenhuma utiliza√ß√£o GPU registrada");
    }
    
    @AfterAll
    void cleanup() {
        // Limpar recursos
        if (simManager != null) {
            simManager.terminateSimulation();
        }
    }
}
```

---

### 6.5 Testes de Performance

```java
package edu.boun.edgecloudsim.performance;

import org.openjdk.jmh.annotations.*;
import java.util.*;
import java.util.concurrent.TimeUnit;

/**
 * Benchmarks de performance para classes GPU.
 */
@State(Scope.Benchmark)
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.MICROSECONDS)
@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)
@Fork(1)
public class GpuPerformanceBenchmark {
    
    private List<Gpu> gpuList;
    private GpuProvisionerSimple provisioner;
    private GpuEdgeVM vm;
    
    @Setup
    public void setUp() {
        // Criar lista de 100 GPUs
        gpuList = new ArrayList<>();
        for (int i = 0; i < 100; i++) {
            gpuList.add(new Gpu(i, "NVIDIA_T4", 2560, 8100.0, 16000, 320.0));
        }
        
        provisioner = new GpuProvisionerSimple(gpuList);
        
        vm = new GpuEdgeVM(1, 1, 10000, 2, 4000, 1000, 10000,
            "Xen", null, null, true);
    }
    
    @Benchmark
    public void benchmarkHasAvailableGpu() {
        provisioner.hasAvailableGpu();
    }
    
    @Benchmark
    public void benchmarkGetAvailableGpu() {
        provisioner.getAvailableGpu();
    }
    
    @Benchmark
    public void benchmarkAllocateGpuForVm() {
        Gpu gpu = provisioner.getAvailableGpu();
        if (gpu != null) {
            provisioner.allocateGpuForVm(vm, gpu);
            provisioner.deallocateGpuForVm(vm);
        }
    }
    
    @Benchmark
    public void benchmarkGetAvailableGpuWithMemory() {
        provisioner.getAvailableGpuWithMemory(8000);
    }
    
    @Benchmark
    public void benchmarkGpuCalculateExecutionTime() {
        gpuList.get(0).calculateExecutionTime(150000);
    }
    
    @Benchmark
    public void benchmarkGpuAllocateMemory() {
        Gpu gpu = gpuList.get(0);
        gpu.allocateMemory(4000);
        gpu.deallocateMemory(4000);
    }
}
```

**Executar benchmarks:**

```bash
mvn clean install
java -jar target/benchmarks.jar GpuPerformanceBenchmark
```

---

### 6.6 Matriz de Casos de Teste

| ID | Categoria | Classe/M√©todo Testado | Objetivo | Prioridade |
|----|-----------|------------------------|----------|------------|
| UT-001 | Unit | Gpu.constructor() | Verificar inicializa√ß√£o | Alta |
| UT-002 | Unit | Gpu.isAvailable() | Verificar disponibilidade | Alta |
| UT-003 | Unit | Gpu.allocateMemory() | Testar aloca√ß√£o de mem√≥ria | Alta |
| UT-004 | Unit | Gpu.calculateExecutionTime() | Testar c√°lculo de tempo | M√©dia |
| UT-005 | Unit | GpuProvisionerSimple.allocateGpuForVm() | Testar aloca√ß√£o GPU para VM | Alta |
| UT-006 | Unit | GpuProvisionerSimple.deallocateGpuForVm() | Testar desaloca√ß√£o GPU | Alta |
| UT-007 | Unit | GpuProvisionerSimple.getAvailableGpu() | Testar busca de GPU dispon√≠vel | Alta |
| UT-008 | Unit | GpuTask.requiresGpu() | Verificar requisito GPU | Alta |
| UT-009 | Unit | GpuTask.getTotalGpuTime() | Testar c√°lculo de tempo total | M√©dia |
| UT-010 | Unit | GpuTask.getGpuIntensity() | Testar c√°lculo de intensidade GPU | M√©dia |
| IT-001 | Integration | GpuEdgeHost + GpuProvisioner | Testar aloca√ß√£o GPU no host | Alta |
| IT-002 | Integration | GpuEdgeVM + GpuCloudletScheduler | Testar submiss√£o de tarefas GPU | Alta |
| IT-003 | Integration | GpuEdgeServerManager + XML | Testar cria√ß√£o de infraestrutura | Alta |
| IT-004 | Integration | GpuEdgeVmAllocationPolicy + GpuEdgeHost | Testar aloca√ß√£o de VMs com GPU | Alta |
| ST-001 | System | Cen√°rio completo GPU | Testar simula√ß√£o end-to-end | Cr√≠tica |
| ST-002 | System | M√©tricas GPU | Verificar coleta de m√©tricas | Alta |
| ST-003 | System | Logging GPU | Verificar gera√ß√£o de logs | M√©dia |
| PT-001 | Performance | GpuProvisioner.getAvailableGpu() | Benchmark de busca de GPU | M√©dia |
| PT-002 | Performance | Gpu.allocateMemory() | Benchmark de aloca√ß√£o de mem√≥ria | Baixa |
| VT-001 | Validation | Resultados vs. Esperados | Comparar com valores te√≥ricos | Alta |

---

## 7. Decis√µes de Design

### 7.1 Decis√£o 1: Modo de Aloca√ß√£o GPU (Exclusive vs. Shared)

**Contexto:**

Uma das decis√µes mais importantes √© definir como GPUs ser√£o compartilhadas entre VMs.

**Op√ß√µes Consideradas:**

| Op√ß√£o | Descri√ß√£o | Vantagens | Desvantagens |
|-------|-----------|-----------|--------------|
| **Exclusive Mode** | 1 GPU : 1 VM | ‚Ä¢ Simples de implementar<br>‚Ä¢ Performance m√°xima para VM<br>‚Ä¢ Sem overhead de context switching | ‚Ä¢ Subutiliza√ß√£o de GPU<br>‚Ä¢ Menor flexibilidade<br>‚Ä¢ Desperd√≠cio de recursos |
| **Shared Mode** | 1 GPU : N VMs | ‚Ä¢ Melhor utiliza√ß√£o de GPU<br>‚Ä¢ Maior flexibilidade<br>‚Ä¢ Suporta mais VMs | ‚Ä¢ Complexidade de implementa√ß√£o<br>‚Ä¢ Overhead de time-slicing<br>‚Ä¢ Performance por VM reduzida |
| **Hybrid Mode** | Configur√°vel por VM | ‚Ä¢ M√°xima flexibilidade<br>‚Ä¢ Balance entre performance e utiliza√ß√£o | ‚Ä¢ Maior complexidade<br>‚Ä¢ Dif√≠cil de otimizar |

**Decis√£o:** Implementar **Exclusive Mode** para MVP (v1.0), com arquitetura preparada para **Shared Mode** futuro.

**Justificativa:**

1. **Simplicidade:** Exclusive mode √© mais f√°cil de implementar e testar
2. **Realismo:** Muitos cen√°rios reais usam exclusive mode (ex: Kubernetes GPU scheduling)
3. **Extensibilidade:** Arquitetura permite adicionar Shared mode sem refatora√ß√£o completa
4. **Valida√ß√£o:** Mais f√°cil validar resultados com aloca√ß√£o 1:1

**Impacto:**

- `GpuProvisionerSimple` implementa exclusive allocation
- `GpuEdgeVM` possui enum `GpuAllocationMode` para futuro
- `GpuCloudletSchedulerTimeShared` j√° suporta time-slicing para shared mode futuro

---

### 7.2 Decis√£o 2: Estrat√©gia de Escalonamento GPU

**Contexto:**

Como m√∫ltiplas tarefas GPU compartilham a GPU dentro de uma VM?

**Op√ß√µes Consideradas:**

| Estrat√©gia | Descri√ß√£o | Adequa√ß√£o |
|------------|-----------|-----------|
| **Space-Shared** | Uma tarefa por vez, outras aguardam | Simples, mas menos realista para GPUs modernas |
| **Time-Shared** | M√∫ltiplas tarefas compartilham via time-slicing | Mais realista para GPUs modernas com preemption |
| **Priority-Based** | Tarefas com maior prioridade executam primeiro | √ötil para QoS, mas aumenta complexidade |

**Decis√£o:** Implementar **Time-Shared** como padr√£o (`GpuCloudletSchedulerTimeShared`).

**Justificativa:**

1. **Realismo:** GPUs modernas (NVIDIA Volta+) suportam Multi-Process Service (MPS) e preemption
2. **Flexibilidade:** Time-shared permite melhor utiliza√ß√£o da GPU
3. **Compatibilidade:** Alinhado com `CloudletSchedulerTimeShared` do CloudSim
4. **Escalabilidade:** Suporta workloads com m√∫ltiplas tarefas concorrentes

**Modelo de Time-Slicing:**

```
GFLOPs por tarefa = Total GFLOPs / N√∫mero de tarefas ativas

Tempo de execu√ß√£o = (GpuLength * 1e6) / GFLOPs por tarefa
```

**Limita√ß√µes:**

- N√£o modela overhead de context switching
- Assume divis√£o igualit√°ria de recursos (sem prioridades)
- N√£o modela conten√ß√£o de mem√≥ria GPU

**Implementa√ß√£o Futura:**

- `GpuCloudletSchedulerSpaceShared` para cen√°rios sem preemption
- Priority-based scheduling com filas priorizadas

---

### 7.3 Decis√£o 3: Modelagem de Tempo de Execu√ß√£o GPU

**Contexto:**

Como calcular o tempo de execu√ß√£o de tarefas GPU de forma realista?

**Componentes do Tempo:**

```
T_total = T_cpu_to_gpu + T_gpu_exec + T_gpu_to_cpu
```

**F√≥rmulas Adotadas:**

1. **Tempo de Transfer√™ncia CPU ‚Üí GPU:**
   ```
   T_cpu_to_gpu = (gpuInputData_MB * 8 bits/byte) / memoryBandwidth_GBps
   ```

2. **Tempo de Execu√ß√£o GPU:**
   ```
   T_gpu_exec = (gpuLength_GFLOPs * 1e6 FLOPs/GFLOPs) / gpu_GFLOPs
   ```

3. **Tempo de Transfer√™ncia GPU ‚Üí CPU:**
   ```
   T_gpu_to_cpu = (gpuOutputData_MB * 8 bits/byte) / memoryBandwidth_GBps
   ```

**Decis√£o:** Usar modelo **GFLOPS-based** com transfer√™ncias de dados expl√≠citas.

**Justificativa:**

1. **Simplicidade:** Modelo linear √© f√°cil de entender e implementar
2. **Adequa√ß√£o:** Apropriado para n√≠vel de abstra√ß√£o do simulador
3. **Parametrizabilidade:** Usu√°rios podem ajustar GFLOPS e bandwidth conforme hardware
4. **Valida√ß√£o:** Poss√≠vel validar contra benchmarks reais (MLPerf, etc.)

**Limita√ß√µes Conhecidas:**

- N√£o modela varia√ß√µes de performance (memory-bound vs. compute-bound)
- N√£o considera cache GPU
- Assume bandwidth constante (n√£o modela conten√ß√£o)
- N√£o modela kernel launch overhead

**Calibra√ß√£o:**

Usu√°rios devem calibrar `gflops` e `memoryBandwidth` baseado em:
- Especifica√ß√µes do fabricante (NVIDIA, AMD)
- Benchmarks reais (e.g., cuda-samples)
- Workload-specific profiling (nvprof, NSight)

---

### 7.4 Decis√£o 4: Estrutura de Heran√ßa vs. Composi√ß√£o

**Contexto:**

Como integrar funcionalidades GPU nas classes existentes do EdgeCloudSim?

**Op√ß√µes Consideradas:**

| Abordagem | Exemplo | Vantagens | Desvantagens |
|-----------|---------|-----------|--------------|
| **Heran√ßa** | `GpuEdgeHost extends EdgeHost` | ‚Ä¢ Natural para OOP<br>‚Ä¢ Reutiliza c√≥digo base<br>‚Ä¢ Polimorfismo | ‚Ä¢ Acoplamento forte<br>‚Ä¢ Hierarquia r√≠gida<br>‚Ä¢ Dificulta m√∫ltiplas extens√µes |
| **Composi√ß√£o** | `EdgeHost { GpuManager gpuMgr }` | ‚Ä¢ Flex√≠vel<br>‚Ä¢ Desacoplado<br>‚Ä¢ F√°cil de testar | ‚Ä¢ Mais boilerplate<br>‚Ä¢ Pode duplicar l√≥gica<br>‚Ä¢ Menos intuitivo |
| **H√≠brida** | Heran√ßa + Interfaces | ‚Ä¢ Balance<br>‚Ä¢ Flexibilidade | ‚Ä¢ Complexidade moderada |

**Decis√£o:** Usar **Heran√ßa** para classes principais + **Interfaces** para comportamentos.

**Estrutura Adotada:**

```
EdgeHost ‚îÄ‚î¨‚îÄ> GpuEdgeHost (heran√ßa)
          ‚îî‚îÄ> usa GpuProvisioner (interface)

EdgeVM ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ> GpuEdgeVM (heran√ßa)
          ‚îî‚îÄ> usa GpuCloudletScheduler (interface)

Task ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ> GpuTask (heran√ßa)
```

**Justificativa:**

1. **Consist√™ncia:** Alinhado com padr√£o do EdgeCloudSim (EdgeHost extends Host)
2. **Simplicidade:** Mais f√°cil para usu√°rios entenderem hierarquia
3. **Polimorfismo:** Permite usar GpuEdgeHost onde EdgeHost √© esperado
4. **Interfaces:** Garantem flexibilidade para diferentes estrat√©gias (GpuProvisioner, GpuCloudletScheduler)

**Trade-offs Aceitos:**

- Acoplamento com classes base do EdgeCloudSim
- Hierarquia de heran√ßa aumenta (3 n√≠veis: Host ‚Üí EdgeHost ‚Üí GpuEdgeHost)
- Dificulta suporte a hosts com GPUs E FPGAs simultaneamente (requer refatora√ß√£o futura)

---

### 7.5 Decis√£o 5: Configura√ß√£o via XML vs. C√≥digo

**Contexto:**

Como usu√°rios especificam configura√ß√µes de GPU (tipo, quantidade, mem√≥ria)?

**Decis√£o:** Estender arquivos XML existentes (`edge_devices.xml`, `applications.xml`).

**Estrutura XML:**

```xml
<!-- edge_devices.xml -->
<host>
    <core>16</core>
    <mips>80000</mips>
    <gpus>  <!-- ‚Üê NOVO -->
        <gpu>
            <gpu_id>0</gpu_id>
            <gpu_type>NVIDIA_T4</gpu_type>
            <cuda_cores>2560</cuda_cores>
            <gflops>8100</gflops>
            <gpu_memory>16000</gpu_memory>
            <memory_bandwidth>320</memory_bandwidth>
        </gpu>
    </gpus>
</host>

<VM>
    <requires_gpu>true</requires_gpu>  <!-- ‚Üê NOVO -->
    <gpu_allocation_mode>EXCLUSIVE</gpu_allocation_mode>  <!-- ‚Üê NOVO -->
</VM>
```

```xml
<!-- applications.xml -->
<application name="DEEP_LEARNING">
    <task_length>50000</task_length>
    <requires_gpu>true</requires_gpu>  <!-- ‚Üê NOVO -->
    <gpu_length>150000</gpu_length>
    <gpu_input_data>2000</gpu_input_data>
    <gpu_output_data>100</gpu_output_data>
    <required_gpu_memory>4000</required_gpu_memory>
</application>
```

**Justificativa:**

1. **Consist√™ncia:** Mant√©m padr√£o do EdgeCloudSim
2. **Facilidade:** Usu√°rios j√° familiarizados com XML
3. **Separa√ß√£o:** Configura√ß√£o separada de c√≥digo
4. **Experimenta√ß√£o:** F√°cil testar diferentes configura√ß√µes sem recompilar

**Alternativas Descartadas:**

- **C√≥digo Java:** Menos flex√≠vel, requer recompila√ß√£o
- **JSON:** Quebra consist√™ncia com EdgeCloudSim
- **YAML:** Requer biblioteca adicional, n√£o standard no Java

---

### 7.6 Decis√£o 6: Logging e M√©tricas GPU

**Contexto:**

Quais m√©tricas GPU devem ser coletadas e como?

**M√©tricas Definidas:**

| Categoria | M√©tricas | Granularidade |
|-----------|----------|---------------|
| **Por Tarefa** | ‚Ä¢ GPU Execution Time<br>‚Ä¢ Data Transfer Time<br>‚Ä¢ GPU Utilization<br>‚Ä¢ GPU Memory Used | Por GpuTask |
| **Por GPU** | ‚Ä¢ Utilization Over Time<br>‚Ä¢ Memory Usage<br>‚Ä¢ Allocated VM<br>‚Ä¢ Idle Time | Periodicament (configurable) |
| **Por VM** | ‚Ä¢ Avg GPU Utilization<br>‚Ä¢ Total GPU Tasks<br>‚Ä¢ GPU Memory Allocated | Agregado |
| **Por Host** | ‚Ä¢ Avg GPU Utilization<br>‚Ä¢ Total GPU Memory<br>‚Ä¢ Number of GPUs | Agregado |

**Formato de Logs:**

**gpu_task_log.csv:**
```csv
Time,MobileDeviceId,VmId,GpuId,TaskId,GpuUtilization,GpuMemoryUsed,GpuExecutionTime,GpuDataTransferTime
10.5,1,0,0,1,80.0,4000,2.5,0.3
```

**gpu_utilization_log.csv:**
```csv
Time,HostId,GpuId,Utilization,UsedMemory,AllocatedVmId
5.0,0,0,60.0,4000,0
10.0,0,0,80.0,4000,0
```

**Decis√£o:** Estender `SimLogger` com m√©todos espec√≠ficos para GPU.

**Implementa√ß√£o:**

```java
public class GpuSimLogger extends SimLogger {
    public void addGpuTaskLog(...) { ... }
    public void addGpuUtilizationLog(...) { ... }
}
```

**Justificativa:**

1. **Separa√ß√£o:** Logs GPU separados de logs CPU
2. **An√°lise:** CSV permite f√°cil an√°lise com Python/MATLAB/R
3. **Performance:** Logs escritos ao final da simula√ß√£o (bulk write)
4. **Extensibilidade:** F√°cil adicionar novas m√©tricas

---

### 7.7 Decis√£o 7: Tratamento de Erros

**Contexto:**

Como lidar com situa√ß√µes de erro (GPU indispon√≠vel, mem√≥ria insuficiente)?

**Estrat√©gias por Situa√ß√£o:**

| Situa√ß√£o | Tratamento | Justificativa |
|----------|------------|---------------|
| **VM requer GPU mas host sem GPU** | Falha na cria√ß√£o da VM, log warning | Evita estado inconsistente |
| **GPU sem mem√≥ria suficiente** | Tarefa rejeitada, status FAILED | Simula comportamento real |
| **Todas GPUs ocupadas** | VM aguarda ou √© rejeitada | Depende da pol√≠tica de aloca√ß√£o |
| **GPU alocada para 2 VMs (bug)** | Exception `IllegalStateException` | Bug cr√≠tico, deve falhar fast |

**Logging de Erros:**

```java
if (!host.hasAvailableGpu()) {
    SimLogger.printLine(CloudSim.clock() + 
        ": VM #" + vm.getId() + " FAILED - No GPU available on host #" + host.getId());
    return false;
}
```

**Decis√£o:** Usar **fail-fast** para bugs + **graceful degradation** para condi√ß√µes normais.

**Implementa√ß√£o:**

- Valida√ß√µes em `allocateGpuForVm()`, `submitGpuTask()`
- Logs detalhados para debugging
- Status `FAILED` para tarefas rejeitadas
- M√©tricas de rejei√ß√£o em logs

---

### 7.8 Resumo de Trade-offs

| Decis√£o | Benef√≠cios | Custos | Mitiga√ß√£o |
|---------|-----------|--------|-----------|
| **Exclusive Mode** | Simples, test√°vel | Subutiliza√ß√£o | Arquitetura extens√≠vel para Shared |
| **Time-Shared Scheduling** | Realista, flex√≠vel | N√£o modela overhead | Calibra√ß√£o com benchmarks |
| **GFLOPS-based Model** | Simples, parametriz√°vel | Limita√ß√µes de realismo | Documentar limita√ß√µes, permitir calibra√ß√£o |
| **Heran√ßa** | Natural, polim√≥rfico | Acoplamento | Usar interfaces para flexibilidade |
| **XML Config** | Consistente, f√°cil | Verboso | Fornecer templates |
| **CSV Logs** | Analis√°vel, padr√£o | Tamanho de arquivo | Compress√£o, logs opcionais |
| **Fail-fast** | Detecta bugs cedo | Menos tolerante | Bons logs de erro |

---

## 8. Anexos

### 8.1 Gloss√°rio de Termos

| Termo | Defini√ß√£o |
|-------|-----------|
| **CUDA Cores** | Unidades de processamento paralelo em GPUs NVIDIA |
| **GFLOPS** | Giga Floating Point Operations Per Second - M√©trica de capacidade computacional |
| **GpuTask** | Tarefa que requer processamento em GPU |
| **Exclusive Mode** | Modo de aloca√ß√£o onde 1 GPU √© dedicada a 1 VM |
| **Shared Mode** | Modo de aloca√ß√£o onde 1 GPU √© compartilhada por m√∫ltiplas VMs |
| **Time-Shared** | Escalonamento onde m√∫ltiplas tarefas compartilham recurso via time-slicing |
| **Space-Shared** | Escalonamento onde uma tarefa usa recurso por vez, outras aguardam |
| **Provisioner** | Componente respons√°vel por alocar recursos (GPU, RAM, etc.) |
| **Memory Bandwidth** | Taxa de transfer√™ncia de dados da mem√≥ria GPU (GB/s) |
| **GPU Utilization** | Percentual de uso da GPU (0-100%) |

---

### 8.2 Refer√™ncias

1. **EdgeCloudSim:**
   - Sonmez, C., Ozgovde, A., & Ersoy, C. (2018). EdgeCloudSim: An environment for performance evaluation of edge computing systems. *Transactions on Emerging Telecommunications Technologies*, 29(11), e3493.
   - GitHub: https://github.com/CagataySonmez/EdgeCloudSim

2. **CloudSim:**
   - Calheiros, R. N., Ranjan, R., Beloglazov, A., De Rose, C. A., & Buyya, R. (2011). CloudSim: a toolkit for modeling and simulation of cloud computing environments and evaluation of resource provisioning algorithms. *Software: Practice and experience*, 41(1), 23-50.
   - GitHub: https://github.com/Cloudslab/cloudsim

3. **GPU Architecture:**
   - NVIDIA CUDA C Programming Guide: https://docs.nvidia.com/cuda/cuda-c-programming-guide/
   - NVIDIA Multi-Process Service (MPS): https://docs.nvidia.com/deploy/mps/index.html

4. **Design Patterns:**
   - Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). *Design patterns: elements of reusable object-oriented software*. Addison-Wesley.

5. **Testing:**
   - Beck, K. (2003). *Test-driven development: By example*. Addison-Wesley Professional.

---

### 8.3 Checklist de Implementa√ß√£o (Fase 3)

**Classes Base:**
- [ ] Implementar classe `Gpu`
- [ ] Implementar interface `GpuProvisioner`
- [ ] Implementar `GpuProvisionerSimple`
- [ ] Implementar classe `GpuTask`

**Infraestrutura Edge:**
- [ ] Implementar `GpuEdgeHost`
- [ ] Implementar `GpuEdgeVM`
- [ ] Implementar interface `GpuCloudletScheduler`
- [ ] Implementar `GpuCloudletSchedulerTimeShared`
- [ ] Implementar `GpuEdgeVmAllocationPolicy_Custom`

**Gerenciamento:**
- [ ] Implementar `GpuEdgeServerManager`
- [ ] Estender `SimSettings` para ler configs GPU do XML
- [ ] Estender `SimLogger` para logs GPU

**Cen√°rio e Testes:**
- [ ] Criar `GpuScenarioFactory`
- [ ] Criar XMLs de exemplo (edge_devices_gpu.xml, applications_gpu.xml)
- [ ] Implementar `GpuLoadGenerator`
- [ ] Implementar `GpuMobileDeviceManager`

**Testes:**
- [ ] Testes unit√°rios para todas as classes (‚â•80% coverage)
- [ ] Testes de integra√ß√£o
- [ ] Teste de sistema end-to-end
- [ ] Benchmarks de performance

**Documenta√ß√£o:**
- [ ] JavaDoc completo para todas as classes p√∫blicas
- [ ] README com instru√ß√µes de uso
- [ ] Tutorial passo-a-passo
- [ ] Exemplos de configura√ß√£o XML

**Valida√ß√£o:**
- [ ] Validar resultados contra benchmarks conhecidos
- [ ] Comparar com simuladores GPU existentes (GPGPU-Sim, etc.)
- [ ] Realizar experimentos com cen√°rios reais

---

### 8.4 Exemplo Completo: MainApp GPU

```java
package edu.boun.edgecloudsim.applications.gpu_app;

import edu.boun.edgecloudsim.core.SimManager;
import edu.boun.edgecloudsim.core.SimSettings;
import edu.boun.edgecloudsim.utils.SimLogger;
import org.cloudbus.cloudsim.core.CloudSim;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

/**
 * Aplica√ß√£o principal para simula√ß√£o com suporte a GPU.
 */
public class MainApp {
    
    public static void main(String[] args) {
        // Configura√ß√µes
        String configFile = "scripts/gpu_app/config/default_config.properties";
        String edgeDevicesFile = "scripts/gpu_app/config/edge_devices.xml";
        String applicationsFile = "scripts/gpu_app/config/applications.xml";
        String outputFolder = "sim_results/gpu_app";
        
        int iterationStart = 1;
        int iterationEnd = 1;
        
        // Parse command line arguments se fornecidos
        if (args.length == 5) {
            configFile = args[0];
            edgeDevicesFile = args[1];
            applicationsFile = args[2];
            outputFolder = args[3];
            int iteration = Integer.parseInt(args[4]);
            iterationStart = iteration;
            iterationEnd = iteration;
        }
        
        // Inicializar SimSettings
        SimSettings.getInstance();
        if (!SimSettings.getInstance().initialize(configFile, edgeDevicesFile, applicationsFile)) {
            SimLogger.printLine("cannot initialize simulation settings!");
            System.exit(1);
        }
        
        // Obter par√¢metros de simula√ß√£o
        DateFormat df = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
        Date startDate = Calendar.getInstance().getTime();
        String startDateStr = df.format(startDate);
        
        SimLogger.printLine("Simulation started at " + startDateStr);
        SimLogger.printLine("----------------------------------------------------------------------");
        
        for (int iterationNumber = iterationStart; iterationNumber <= iterationEnd; iterationNumber++) {
            
            String iterationOutputFolder = outputFolder + "/ite" + iterationNumber;
            
            for (int j = 0; j < SimSettings.getInstance().getScenarioCount(); j++) {
                for (int k = 0; k < SimSettings.getInstance().getOrchestratorPolicyCount(); k++) {
                    
                    String simScenario = SimSettings.getInstance().getScenario(j);
                    String orchestratorPolicy = SimSettings.getInstance().getOrchestratorPolicy(k);
                    
                    Date scenarioStartDate = Calendar.getInstance().getTime();
                    String scenarioStartDateStr = df.format(scenarioStartDate);
                    
                    SimLogger.printLine("----------------------------------------------------------------------");
                    SimLogger.printLine("Scenario: " + simScenario + 
                                        " - Policy: " + orchestratorPolicy + 
                                        " - Iteration: " + iterationNumber);
                    SimLogger.printLine("Start Time: " + scenarioStartDateStr);
                    SimLogger.printLine("----------------------------------------------------------------------");
                    
                    // Inicializar CloudSim
                    int numBrokers = 1;
                    boolean traceFlag = false;
                    Calendar calendar = Calendar.getInstance();
                    CloudSim.init(numBrokers, calendar, traceFlag);
                    
                    // Criar factory GPU
                    int numMobileDevices = SimSettings.getInstance().getMinNumOfMobileDev();
                    double simulationTime = SimSettings.getInstance().getSimulationTime();
                    
                    GpuScenarioFactory scenarioFactory = new GpuScenarioFactory(
                        numMobileDevices,
                        simulationTime,
                        orchestratorPolicy,
                        simScenario
                    );
                    
                    // Criar e iniciar SimManager
                    SimManager simManager = new SimManager(
                        scenarioFactory,
                        numMobileDevices,
                        simScenario,
                        iterationOutputFolder
                    );
                    
                    try {
                        simManager.startSimulation();
                    } catch (Exception e) {
                        SimLogger.printLine("Simulation failed!");
                        e.printStackTrace();
                        System.exit(1);
                    }
                    
                    Date scenarioEndDate = Calendar.getInstance().getTime();
                    String scenarioEndDateStr = df.format(scenarioEndDate);
                    
                    long duration = (scenarioEndDate.getTime() - scenarioStartDate.getTime()) / 1000;
                    
                    SimLogger.printLine("----------------------------------------------------------------------");
                    SimLogger.printLine("Scenario completed!");
                    SimLogger.printLine("End Time: " + scenarioEndDateStr);
                    SimLogger.printLine("Duration: " + duration + " seconds");
                    SimLogger.printLine("----------------------------------------------------------------------");
                }
            }
        }
        
        Date endDate = Calendar.getInstance().getTime();
        String endDateStr = df.format(endDate);
        
        SimLogger.printLine("----------------------------------------------------------------------");
        SimLogger.printLine("Simulation finished at " + endDateStr);
        SimLogger.printLine("----------------------------------------------------------------------");
    }
}
```

---

## üéØ Conclus√£o

Este documento fornece o **design completo e detalhado** das classes GPU para o **GpuEdgeCloudSim v1.0**, incluindo:

‚úÖ **Especifica√ß√µes de API completas** para 10 classes principais  
‚úÖ **Diagramas UML detalhados** (classes, pacotes, relacionamentos)  
‚úÖ **Contratos de interfaces** com JavaDoc completo  
‚úÖ **Diagramas de sequ√™ncia** para 4 fluxos principais  
‚úÖ **7 exemplos de uso** pr√°ticos e funcionais  
‚úÖ **Estrat√©gia de testes** com matriz de casos e exemplos de c√≥digo  
‚úÖ **7 decis√µes de design** documentadas com trade-offs  
‚úÖ **Anexos** com gloss√°rio, refer√™ncias e checklist

### Pr√≥ximos Passos (Fase 3 - Implementa√ß√£o)

1. ‚úÖ **Fase 2 Completa** ‚Üê Voc√™ est√° aqui
2. ‚è≠Ô∏è **Fase 3: Implementa√ß√£o**
   - Implementar todas as classes seguindo este design
   - Escrever testes unit√°rios e de integra√ß√£o
   - Validar com cen√°rios reais
3. ‚è≠Ô∏è **Fase 4: Experimenta√ß√£o**
   - Executar simula√ß√µes completas
   - Coletar e analisar resultados
   - Comparar com sistemas reais
4. ‚è≠Ô∏è **Fase 5: Publica√ß√£o**
   - Escrever artigo cient√≠fico
   - Publicar c√≥digo no GitHub
   - Criar documenta√ß√£o de usu√°rio

---

**Documento gerado por:** Pabllo Borges Cardoso  
**Data:** 23 de Outubro de 2025  
**Vers√£o:** 1.0  
**Status:** ‚úÖ Completo e Aprovado para Implementa√ß√£o

---

**üìÑ Arquivo:** `/home/ubuntu/GpuEdgeCloudSim_Fase2_Design_Classes_GPU.md`
